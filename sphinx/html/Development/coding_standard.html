

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Coding Standard &mdash; cleanMind 0.0.1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Readme" href="../readme.html" />
    <link rel="prev" title="Development" href="../Development.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> cleanMind
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">CONTENT</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../Trade.html">Trade</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../Development.html">Development</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Coding Standard</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#must-have-rules">MUST-HAVE rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#good-practice-rules">GOOD PRACTICE rules</a></li>
<li class="toctree-l3"><a class="reference internal" href="#introduction">Introduction</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#scope">Scope</a></li>
<li class="toctree-l4"><a class="reference internal" href="#enforcement">Enforcement</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#naming">Naming</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#files">Files</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pragma-once">#pragma once</a></li>
<li class="toctree-l4"><a class="reference internal" href="#namespaces">Namespaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#types">Types</a></li>
<li class="toctree-l4"><a class="reference internal" href="#enumerations">Enumerations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#functions">Functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#variables-and-parameters">Variables and parameters</a></li>
<li class="toctree-l4"><a class="reference internal" href="#macros">Macros</a></li>
<li class="toctree-l4"><a class="reference internal" href="#templates">Templates</a></li>
<li class="toctree-l4"><a class="reference internal" href="#definition-in-source-file-or-header-file">Definition in source file or header file</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#formatting">Formatting</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#indentation-and-whitespace">Indentation and whitespace</a></li>
<li class="toctree-l4"><a class="reference internal" href="#classes-and-constructors">Classes and constructors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#blocks">Blocks</a></li>
<li class="toctree-l4"><a class="reference internal" href="#loops-and-control-statements">Loops and control statements</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#comments">Comments</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#logging-program-execution">Logging program execution</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#assertions">Assertions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#use-compile-time-assertions-instead-of-run-time-assertions">Use compile-time assertions instead of run-time assertions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#never-use-assert">Never use assert()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#never-use-aaerrorassert">Never use AaErrorAssert()</a></li>
<li class="toctree-l4"><a class="reference internal" href="#never-use-assertions-where-error-handling-is-feasible">Never use assertions where error handling is feasible</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#c-features">C++ Features</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#classes">Classes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#undefined-and-unspecified-behaviour">Undefined and unspecified behaviour</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memset-vs-std-fill-n">memset vs std::fill_n</a></li>
<li class="toctree-l4"><a class="reference internal" href="#always-use-value-initialization-to-set-memory-to-zero">Always use value initialization to set memory to zero</a></li>
<li class="toctree-l4"><a class="reference internal" href="#never-use-memcpy-instead-of-copy-constructor">Never use memcpy() instead of copy constructor</a></li>
<li class="toctree-l4"><a class="reference internal" href="#alternative-operators">Alternative operators</a></li>
<li class="toctree-l4"><a class="reference internal" href="#type-aliases-using-typedef">Type aliases – using, typedef</a></li>
<li class="toctree-l4"><a class="reference internal" href="#usage-of-standard-boost-and-other-libraries">Usage of Standard, Boost and other libraries</a></li>
<li class="toctree-l4"><a class="reference internal" href="#memory-management">Memory management</a></li>
<li class="toctree-l4"><a class="reference internal" href="#type-casts">Type casts</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exceptions">Exceptions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#containers">Containers</a></li>
<li class="toctree-l4"><a class="reference internal" href="#algorithms">Algorithms</a></li>
<li class="toctree-l4"><a class="reference internal" href="#functors">Functors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#lambdas">Lambdas</a></li>
<li class="toctree-l4"><a class="reference internal" href="#const-usage">Const usage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#inline-functions">Inline functions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#explicit-constructors">Explicit constructors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#static-usage">Static usage</a></li>
<li class="toctree-l4"><a class="reference internal" href="#function-parameter-order">Function parameter order</a></li>
<li class="toctree-l4"><a class="reference internal" href="#ternary-operator">Ternary operator</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#header-n391">Idioms and design patterns</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#resource-acquisition-is-initialization">Resource Acquisition Is Initialization</a></li>
<li class="toctree-l4"><a class="reference internal" href="#header-n398">Interfaces</a></li>
<li class="toctree-l4"><a class="reference internal" href="#crtp">CRTP</a></li>
<li class="toctree-l4"><a class="reference internal" href="#source-sink">Source/sink</a></li>
<li class="toctree-l4"><a class="reference internal" href="#policy-classes-and-type-traits">Policy classes and type traits</a></li>
<li class="toctree-l4"><a class="reference internal" href="#private-implementation-pimpl">Private Implementation (pImpl)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#filesystem-system-interactions-dependency-injection">Filesystem, system interactions – Dependency Injection</a></li>
<li class="toctree-l4"><a class="reference internal" href="#smart-pointers-pointers-and-references-when-to-use">Smart pointers, pointers and references – when to use?</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#refactoring">Refactoring</a></li>
<li class="toctree-l3"><a class="reference internal" href="#testing-ut">Testing - UT</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#strategy">Strategy</a></li>
<li class="toctree-l4"><a class="reference internal" href="#structure">Structure</a></li>
<li class="toctree-l4"><a class="reference internal" href="#pre-conditions-and-post-conditions">Pre-conditions and post-conditions</a></li>
<li class="toctree-l4"><a class="reference internal" href="#logging-test-execution">Logging test execution</a></li>
<li class="toctree-l4"><a class="reference internal" href="#unit-tests-vs-system-component-tests-sct">Unit tests vs. System Component Tests (SCT)</a></li>
<li class="toctree-l4"><a class="reference internal" href="#header-n605">Refactoring</a></li>
<li class="toctree-l4"><a class="reference internal" href="#naming-convention">Naming convention</a></li>
<li class="toctree-l4"><a class="reference internal" href="#test-suites">Test suites</a></li>
<li class="toctree-l4"><a class="reference internal" href="#test-cases">Test cases</a></li>
<li class="toctree-l4"><a class="reference internal" href="#header-n652">Comments</a></li>
<li class="toctree-l4"><a class="reference internal" href="#helper-code">Helper code</a></li>
<li class="toctree-l4"><a class="reference internal" href="#google-mock-compilation-speed-up">Google mock compilation speed-up</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#terms-and-abbreviations">Terms and Abbreviations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../readme.html">Readme</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">cleanMind</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../Development.html">Development</a> &raquo;</li>
        
      <li>Coding Standard</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/Development/coding_standard.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="coding-standard">
<span id="header-n0"></span><h1>Coding Standard<a class="headerlink" href="#coding-standard" title="Permalink to this headline">¶</a></h1>
<div class="section" id="must-have-rules">
<span id="header-n3"></span><h2>MUST-HAVE rules<a class="headerlink" href="#must-have-rules" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Align code with the formatting described in the standard. Spaces must
be used instead of tabs for indentation. Block brackets {} must be
placed in the next line at the same level of indentation, i.e. shall
follow the Allman specification.</p></li>
<li><p>Do not use using namespace in header files.</p></li>
<li><p>Do not use following #ifdefs as: #ifdef UT, #ifdef SCT, #ifdef 0
(same for #ifndef).</p></li>
<li><p>Members in class have to conform to order listed in this Standard.
Refer to chapter 3.2 for details.</p></li>
<li><p>For any class with virtual methods or any base class destructor
should be marked as virtual.</p></li>
<li><p>Do not use memcpy for non-POD structures.</p></li>
<li><p>Use standard library as much as possible. When looking for
functionality you should look for it in following order: std, boost,
ccs, implement it by yourself.</p></li>
<li><p>Avoid using raw pointers to indicate memory ownership. Refer to
chapter 7.8 for details.</p></li>
<li><p>Do not use name prefixes.</p></li>
<li><p>Never check for NULL after allocation with new keyword, don’t use new
(no throw).</p></li>
<li><p>When using functions which may throw an exception, always consider
whether it is possible that the function will throw and if so, take
steps to handle it to avoid application termination.</p></li>
<li><p>For system calls use dedicated classes instead of directly executing
commands. Thanks to this your code will be easier to test (refer to
7.7 for details).</p></li>
<li><p>Unit Test shall run in less than 100 ms.</p></li>
<li><p>Unit Test shall test 1 class only and be small enough to help you
localize problems when it fails.</p></li>
<li><p>Do not declare multiple variables in one line.</p></li>
</ul>
</div>
<div class="section" id="good-practice-rules">
<span id="header-n36"></span><h2>GOOD PRACTICE rules<a class="headerlink" href="#good-practice-rules" title="Permalink to this headline">¶</a></h2>
<ul class="simple">
<li><p>Formatting tool shall be added to each repository along with
configuration file. It is preferred that each developer runs the tool
before making code public, either via commit or before publishing
diff.</p></li>
<li><p>Do not create new macros.</p></li>
<li><p>Use enum class for new enums.</p></li>
<li><p>If you are overriding method, use override keyword.</p></li>
<li><p>Use #pragma once instead of include guards.</p></li>
<li><p>Preserve appropriate order of includes (see chapter 6.1.5 for
details).</p></li>
<li><p>Use static for members, methods and globals where applicable.</p></li>
<li><p>Use const for input parameters, methods, local variables and data
members where applicable.</p></li>
<li><p>Use angled brackets &lt;&gt; for std includes, everything else shall be put
in “”.</p></li>
<li><p>Use using namespace in source files only when necessary, in smallest
scope possible.</p></li>
<li><p>Prefer Copy constructor/dedicated methods instead of memcpy.</p></li>
<li><p>If you do not need some code, remove it instead of commenting it out.
When you see commented out code – remove it.</p></li>
<li><p>When writing code, have a saying “premature optimization is a root of
all evil” in mind. Treat code more like a human readable
documentation rather than a set of instructions.</p></li>
<li><p>Avoid out parameters – prefer returning value.</p></li>
<li><p>Header files are not designed to save you from typing. Avoid common
includes files. Include only what you need.</p></li>
<li><p>Avoid creating functions longer than 20 lines.</p></li>
<li><p>When hardcoded value is not self explanatory enough, consider a named
constant.</p></li>
<li><p>Put standalone global functions into namespaces, with exception for
functions which have to be in the global namespace, operators and
specific overloads.</p></li>
</ul>
</div>
<div class="section" id="introduction">
<span id="header-n74"></span><h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>It is always reasonable to encourage consistency of coding style.
Application of the Scrum methodology, however, places a higher level of
importance that there is consistency across code-bases, because lack of
such consistency steepens the learning curve associated with moving
developers from one system component to another. Keeping the code and
design consistent is crucial for fast introduction of new features.</p>
<p>The coding standard goes beyond just consistency – it sets out
recommendations for good practice.</p>
<div class="section" id="scope">
<span id="header-n77"></span><h3>Scope<a class="headerlink" href="#scope" title="Permalink to this headline">¶</a></h3>
<p>Rules described in this document apply to all source code belonging to
MBB Small Cell project, regardless if they are new, inherited or just
old. It is developer’s responsibility to keep source code aligned with
coding standard during normal workflow. E.g. when one encounters an old,
outdated code, it should be made compliant to this guideline before
starting feature implementation.</p>
<p>Recommendations should be followed as much as possible, however
additional design rules are more of a guideline – code should conform to
them, but if there are reasonable concerns about the default solution,
developer is free to do the implementation in their own way. That being
said, such a decision must be well documented so other people will not
try to “fix” the code and encounter the same problems which resulted in
abandoning the default approach.</p>
</div>
<div class="section" id="enforcement">
<span id="header-n80"></span><h3>Enforcement<a class="headerlink" href="#enforcement" title="Permalink to this headline">¶</a></h3>
<p>Rules are strong coding requirements and must be followed by all
developers within the project team. The compliance with rules is
mandatory.</p>
<p>Breaking rules is allowed for good reasons only and must be clearly
documented in the code (comment). The non-compliance also must be
accepted by every code reviewer.</p>
<p>Some rules and recommendations of this guide will be implicitly checked
by tools like Klocwork. However, many rules cannot be checked
automatically. This task is left to code reviews.</p>
</div>
</div>
<div class="section" id="naming">
<span id="header-n84"></span><h2>Naming<a class="headerlink" href="#naming" title="Permalink to this headline">¶</a></h2>
<div class="section" id="files">
<span id="header-n85"></span><h3>Files<a class="headerlink" href="#files" title="Permalink to this headline">¶</a></h3>
<p>Extensions for C++ headers files shall be .h, for source files use .cpp
extension. For C, extensions are .c and .h. Note that C headers should
include #ifdef __cplusplus extern “C” sections. If header does not
provide this, consider wrapping it into a .h file with structure as in
listing.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef __cplusplus</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span>
<span class="p">{</span>
<span class="cp">#endif</span>

<span class="cp">#include</span> <span class="cpf">&quot;foo.h&quot;</span><span class="cp"></span>

<span class="cp">#ifdef __cplusplus</span>
<span class="p">}</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>Files should not be prefixed with system component name.</p>
<p>To avoid name clashes, additional prefixes might be needed. In such
case, additional prefixes shall follow camel case naming.</p>
<p>The file name should reflect its content, i.e. should contain at least
one class named as the file name.</p>
</div>
<div class="section" id="pragma-once">
<span id="header-n91"></span><h3>#pragma once<a class="headerlink" href="#pragma-once" title="Permalink to this headline">¶</a></h3>
<p>All header files shall include #pragma once directive in order to
prevent multiple inclusion of the same header file at compile time. Do
not use header guards for the same purpose.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>
<span class="cm">/* ... */</span>
</pre></div>
</div>
</div>
<div class="section" id="namespaces">
<span id="header-n94"></span><h3>Namespaces<a class="headerlink" href="#namespaces" title="Permalink to this headline">¶</a></h3>
<p>Namespace names follow the same naming convention as functions, i.e.
camelCase. Namespace bodies shall not be indented. Components which
compile to executable, for example CellP or DspProxy, should not have
their own root namespace. Library code, for example PIL, libOM_utils,
should all be located in some root namespace – e.g. PIL should have pil
namespace, and utils should be in omUtils, in order to allow easier
naming and avoid conflicts in library code. Prefer flat namespaces;
having nested directories is fine, but there should not be nested
namespaces, unless to hide it from possible users of the code.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">enbc</span>
<span class="p">{</span>
<span class="k">namespace</span> <span class="n">serverManager</span>
<span class="p">{</span>
<span class="k">class</span> <span class="nc">IdManagement</span>
<span class="p">{</span>
<span class="cm">/* ... */</span>
<span class="p">};</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Namespace aliases and using directives are allowed only in source code
files. It is forbidden to put them globally into header files, do not
use using namespace there as it pollutes global namespace. An exception
are unit test source files where making a using statement for ::testing
namespace or its members is allowed.</p>
<p>Namespace aliases should refer to global scope, starting with ::.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">namespace</span> <span class="n">fsm</span> <span class="o">=</span> <span class="o">::</span><span class="n">common</span><span class="o">::</span><span class="n">fsm</span><span class="p">;</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">fsm</span><span class="o">::</span><span class="n">Event</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">i</span> <span class="cm">/* ... */</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>These rules does not include using in contex of creation type alias
(refer chapter 6.7)</p>
</div>
<div class="section" id="types">
<span id="header-n101"></span><h3>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h3>
<p>Type names should start with capital letter (UpperCamelCase). Acronyms
like SampleRrdType should be avoided, but are allowed.</p>
<p>Naming rules apply to all user-defined types, including enumerations,
nested types, template parameters and so on. When an acronym has to be
used, it is appropriate to only use upper case letter for first letter
in the acronym, such as Rdd instead of RDD.</p>
<p>As an exception, types that have the same semantics as types defined in
standard library should have names conforming to STL acronym naming
convention. This applies especially to iterator, const<em>iterator and
value</em>type defined for custom containers. This is required by STL, in
order to enable standard algorithms and iterators to work on
user-defined types.</p>
<p>Types or variable names should not suggest the underlying structure type
(e.g. list, array, map) unless they actually implement a list or an
array, etc. Plural form can be used instead or at most generic hint like
container or collection. Typedefs are an exception to these rules, as
they define an alias, rather than a new type.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="n">Type</span> <span class="n">OtherType</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">UeId</span><span class="o">&gt;</span> <span class="n">UeIdsVector</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Structure</span>
<span class="p">{</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Class</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Class</span><span class="p">();</span>
    <span class="o">~</span><span class="n">Class</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">privateField</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Something</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Template</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">typedef</span> <span class="n">Something</span> <span class="n">Type</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">LinkContainer</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">PciToResolveList</span><span class="p">;</span> <span class="c1">// discouraged</span>

<span class="k">class</span> <span class="nc">PcisToResolve</span><span class="p">;</span> <span class="c1">// recommended</span>
</pre></div>
</div>
</div>
<div class="section" id="enumerations">
<span id="header-n107"></span><h3>Enumerations<a class="headerlink" href="#enumerations" title="Permalink to this headline">¶</a></h3>
<p>Enumerated type name should follow naming convention of other types. For
new enums always use enum class introduced by C++11. This eliminates the
name conflict issue associated with the C++98 enums.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">enum</span> <span class="k">class</span> <span class="nc">MyEnum</span>
<span class="p">{</span>
    <span class="n">Foo</span><span class="p">,</span>
    <span class="n">Bar</span><span class="p">,</span>
    <span class="n">Qux</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="functions">
<span id="header-n110"></span><h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<p>Function names should begin with a small letter. Generally, the first
word of the function name should be a verb, although generic verbs like
”do”, ”perform”, ”process” etc. should be avoided, but can be used as a
prefix (e.g. processScheduledJobs). This applies to methods, static
methods and free functions as well.</p>
<p><a class="reference external" href="https://bts.inside.nokiasiemensnetworks.com/twiki/bin/view/LTEeNB/CommonReviewPrinciples#MeaningfulNaming">Meaningful naming for functions has been discussed on this wiki
page.</a></p>
<p>Following generic naming recommendations should be applied:</p>
<ul class="simple">
<li><p>For classes and function names: the bigger the scope, the shorter the
name should be (more generic),</p></li>
<li><p>For variables: the bigger the scope, the longer the name should be
(more descriptive).</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Observer</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Observer</span><span class="p">()</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">LinkEstablishmentObserver</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Observer</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
      <span class="n">foo</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">UeLoadBalancer</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">bar</span><span class="p">();</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">chooseUesForPushingOutOfCellByItsPriority</span><span class="p">();</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">UeId</span><span class="o">&gt;</span> <span class="n">ueIdsReservedForAllocationsDueToCollisions</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">updateAllUesWithValue</span><span class="p">(</span><span class="n">Value</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">myObject</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">setValue</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>“Begin with a verb” recommendation does not apply to standard names
taken from STL, like <code class="docutils literal notranslate"><span class="pre">begin()</span></code>, <code class="docutils literal notranslate"><span class="pre">empty()</span></code>, etc. In this case
semantics must be exactly the same as defined in standard library,
including const and <code class="docutils literal notranslate"><span class="pre">throw()</span></code> constraints.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Container</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">class</span> <span class="nc">iterator</span><span class="p">;</span>
    <span class="n">iterator</span> <span class="nf">begin</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="variables-and-parameters">
<span id="header-n123"></span><h3>Variables and parameters<a class="headerlink" href="#variables-and-parameters" title="Permalink to this headline">¶</a></h3>
<p>Variable names shall follow lower camel case notation for both const and
non-const. Acronyms in variables names shall also follow camel case
(e.g. lockBtsomDelta instead of lockBTSOMDelta).</p>
<p>Adding a variable to a large, existing set of variables – in that case a
local naming convention might be applied: Variable names shall not be
prefixed with scope information. Do not use: p<em>, m</em>, <a href="#id6"><span class="problematic" id="id7">l_</span></a>, ptr, or any
other name prefixes.</p>
<p>Postfixing or prefixing variable name with type information (so-called
Hungarian notation) is not permitted, as it is considered harmful from
maintenance point of view and is not needed in strongly typed languages
like C++. This restriction includes shortened Hungarian notation, with
prefixes for pointer and reference types (e.g. rReference or pPointer).
Variable names should not suggest their underlying structure, e.g. list,
array, map.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>const char* globalConstCStyleString = “some value”;

struct Structure
{
    int publicField;
};

class MyClass
{
public:
    int getField() const;
    void setField(int value);
    int publicField; // discouraged

private:
    int privateField; // recommended!
    int* counterPtr; // discouraged
    std::list&lt;int&gt; numberList; // discouraged
    std::list&lt;int&gt; numbers; // recommended!
};

MyClass globalObject; // permissible, although global objects are discouraged

int function(int formalArgument)
{
    int localCopy = formalArgument;
    return localCopy;
}
</pre></div>
</div>
</div>
<div class="section" id="macros">
<span id="header-n128"></span><h3>Macros<a class="headerlink" href="#macros" title="Permalink to this headline">¶</a></h3>
<p>Macros shall be avoided where possible. Macro names shall consist of all
capital letters and shall include component prefix. Macro arguments
shall follow the same naming convention as functions’ arguments.</p>
<p>Local macros shall be undefined as soon as possible. It is also advised
to produce compilation error when multiple definitions occur.</p>
<p>Multi-statement macros should be encased in do { } while(0) blocks to
avoid errors in if else blocks. For improved readability, backslashes
should be aligned to right.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#ifdef ENBC_MACRO</span>
<span class="cp">#error ENBC_MACRO already defined!</span>
<span class="cp">#else</span>
<span class="cp">#define ENBC_MACRO(function, argument) \</span>
<span class="cp">    do \</span>
<span class="cp">    { \</span>
<span class="cp">        somePrefix##function(argument); \</span>
<span class="cp">    } while (0)</span>
<span class="cp">#endif</span>
<span class="n">ENBC_MACRO</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span> <span class="s">&quot; bar&quot;</span><span class="p">);</span>
<span class="cp">#undef ENBC_MACRO</span>
</pre></div>
</div>
</div>
<div class="section" id="templates">
<span id="header-n134"></span><h3>Templates<a class="headerlink" href="#templates" title="Permalink to this headline">¶</a></h3>
<p>Templates shall be named in the same convention as standalone types.
Template parameters shall be named the same as types, regardless if they
are type or non-type parameters. Prefer declaring type parameters with
typename keyword over class (both forms are allowed, though).</p>
</div>
<div class="section" id="definition-in-source-file-or-header-file">
<span id="header-n136"></span><h3>Definition in source file or header file<a class="headerlink" href="#definition-in-source-file-or-header-file" title="Permalink to this headline">¶</a></h3>
<p>When deciding whether method definition should go to source or header,
main rule to follow is consistency. In presence of source file
corresponding to the header, all method definitions should go to that
source file.</p>
<p>Header-only classes are allowed and should have a .h extension as any
other header.</p>
</div>
</div>
<div class="section" id="formatting">
<span id="header-n139"></span><h2>Formatting<a class="headerlink" href="#formatting" title="Permalink to this headline">¶</a></h2>
<p>Consistent code formatting helps during merging and patching the code.
For this purpose there were created tool to make formatting
consistent[Formatter]. Code need to be formatted as it would be
formatted by tool. It is advised to make change sets as small as
possible (including formatting changes) so they can be easily examined.
Therefore developers should disable extensive automatic code
reformatting in their tool of choice.</p>
<p>If the file requires extensive reformatting, it should be done as a
separate check-in in CM tool, before starting actual implementation.
This is to avoid difficult merging and patching.</p>
<div class="section" id="indentation-and-whitespace">
<span id="header-n142"></span><h3>Indentation and whitespace<a class="headerlink" href="#indentation-and-whitespace" title="Permalink to this headline">¶</a></h3>
<p>Tabs are forbidden, code shall be indented with 4 spaces per level. Do
not put white space characters at the end of line. Single whitespace
shall be added before opening parenthesis in control statements like if,
for, while, catch or switch. Do not put whitespace before opening
parenthesis when declaring or calling a function, or constructing an
objectFormatting should conform rules defined in .clang-format file.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>void foo()
{
····// 1st level
····if (...)
····{
········bar(); // 2nd level
····}
····myFunction(param1, param2);
····MyClass object(param3);
}
</pre></div>
</div>
<p>Functions and control statements with long parameter lists should be
indented with spaces either up to opening brace or, in case of a long
function name, with parameters in separate lines, as presented in the
example below. Also, one might want to keep formal parameters’ names in
one column.</p>
<p>When dealing with long expressions, break the line before the operator,
so next lines begin with one. When dealing with bool operators, surround
complex predicates in parentheses to avoid ambiguity.</p>
<p>As a general rule, try to keep lines below 110 characters. The rationale
is:</p>
<ul class="simple">
<li><p>Makes it is easier to print the code,</p></li>
<li><p>makes it is easier to do 2-pane diff,</p></li>
<li><p>other people’s IDE (acronym) panels would not cover the text.</p></li>
</ul>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>void foo(const ArgumentOne &amp;argument1,
·········const ArgumentTwo &amp;argument2,
·········const ArgumentThree &amp;argument3,
·········const ArgumentFour &amp;argument4,
·········const ArgumentFive &amp;argument5)
{
····SomeValue&amp; value = foo.getBar().getQux();
····if (!value.empty() &amp;&amp; value[0] == 5 &amp;&amp; predicate3)
····{
········doSomething();
····}
}

void veryLongAndDescriptiveFunctionName(
····const ArgumentOne &amp;argument1,
····const ArgumentTeo &amp;argument2)
{
····handleMessage();
}
</pre></div>
</div>
</div>
<div class="section" id="classes-and-constructors">
<span id="header-n156"></span><h3>Classes and constructors<a class="headerlink" href="#classes-and-constructors" title="Permalink to this headline">¶</a></h3>
<p>Initialization lists in constructors shall begin on a new line with
indented colon. When initialization list does not fit in one line, each
initialization should be written on a separate line:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>Foo::Foo(int initializer)
····: firstMember(initializer),
······secondMember(initializer),
······thirdMember(initializer + 1),
······fourthMember(initializer + 2),
······fifthMember(initializer + 3),
{
}
</pre></div>
</div>
<p>When initialization list does fit in single line, it is fine to put all
initialization in same line:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Foo</span><span class="o">::</span><span class="n">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">initializer</span><span class="p">)</span> <span class="o">:</span> <span class="n">firstMember</span><span class="p">(</span><span class="n">initializer</span><span class="p">),</span> <span class="n">secondMember</span><span class="p">(</span><span class="n">initializer</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<blockquote>
<div><p>Listing 14. Initialization list formatting – with short
initialization list.</p>
</div></blockquote>
<p>A class definition should start with its public: section, followed by
its protected: section and then its private: section. If any of these
are empty, omit them.</p>
<p>Within each section, member declaration should appear as in stated
below:</p>
<ul class="simple">
<li><p>enums,</p></li>
<li><p>nested types, typedefs, usings,</p></li>
<li><p>static const data members,</p></li>
<li><p>constructors,</p></li>
<li><p>destructor,</p></li>
<li><p>methods,</p></li>
<li><p>data members (except static const data members).</p></li>
</ul>
<p>There is one exception – friend declarations should always be in the
private section on the beginning of the class:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Foo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">boost</span><span class="o">::</span><span class="n">noncopyable</span>
<span class="p">{</span>
    <span class="k">friend</span> <span class="k">class</span> <span class="nc">Other</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">class</span> <span class="nc">iterator</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="n">Foo</span><span class="p">();</span>
    <span class="o">~</span><span class="n">Foo</span><span class="p">();</span>

    <span class="kt">void</span> <span class="nf">foo</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">publicVariable</span><span class="p">;</span> <span class="c1">// discouraged</span>

<span class="k">protected</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">bar</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">protectedVar</span><span class="p">;</span> <span class="c1">// discouraged</span>

<span class="k">private</span><span class="o">:</span>
    <span class="k">typedef</span> <span class="n">til</span><span class="o">::</span><span class="n">Holder</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">Holder</span><span class="p">;</span>
    <span class="n">Holder</span> <span class="n">member</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="blocks">
<span id="header-n184"></span><h3>Blocks<a class="headerlink" href="#blocks" title="Permalink to this headline">¶</a></h3>
<p>Opening and closing braces shall have the same level of indentation and
should be placed in the next line. Presence of braces in one liners is
not obligatory, when in doubt whether braces improve readability in
particular case just add them.Do not use comments to mark end of blocks
such as //end if.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Class</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">getInt</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="kt">int</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">someOtherStuff</span><span class="p">();</span>
<span class="p">};</span>

<span class="kt">bool</span> <span class="n">Class</span><span class="o">::</span><span class="n">someOtherStuff</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">try</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">getInt</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">bool</span> <span class="n">returnValue</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
            <span class="c1">// some logic follows...</span>
            <span class="k">return</span> <span class="n">returnValue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span> <span class="o">&amp;</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// some exception handling</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">getFive</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="loops-and-control-statements">
<span id="header-n188"></span><h3>Loops and control statements<a class="headerlink" href="#loops-and-control-statements" title="Permalink to this headline">¶</a></h3>
<p>Switch statements shall be formatted like below. Try to avoid long
switch tables as they are very hard to maintain. Presence of default
section depends on the use case – when all values of an enum are to be
covered, then default shall be omitted, as on addition of new case this
will result in compilation warning. Add default case only when we
intentionally do not cover all cases.</p>
<p>The above applies when we are switching based on ‘enum’ type. On value
types, always include default section.</p>
<p>By default, all switch cases should include break statement; this of
course does not apply to switch-based conversion functions, where every
case is followed by immediate return or throw/assert statement.</p>
<p>Avoid fall-through cases; it’s allowed only for cases without code.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">convertEnumAToInt</span><span class="p">(</span><span class="n">EnumA</span> <span class="n">value</span><span class="p">)</span> <span class="c1">// static check - compilation warning</span>
<span class="p">{</span> <span class="c1">// on missing case label</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">foo</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="n">Foo</span><span class="o">::</span><span class="nl">A</span><span class="p">:</span>
            <span class="n">bar</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">Foo</span><span class="o">::</span><span class="nl">B</span><span class="p">:</span>
        <span class="k">case</span> <span class="n">Foo</span><span class="o">::</span><span class="nl">CC</span><span class="p">:</span>
            <span class="n">qux</span><span class="p">();</span>
            <span class="k">break</span><span class="p">;</span>

        <span class="c1">// note lack of default statement!</span>
    <span class="p">}</span>

    <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">logic_error</span><span class="p">(</span><span class="s">&quot;Unknown Foo&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">convertEnumAToInt</span><span class="p">(</span><span class="n">EnumA</span> <span class="n">value</span><span class="p">)</span> <span class="c1">// runtime check - will result in exception in</span>
<span class="p">{</span> <span class="c1">// case of unexpected enum value</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">case</span> <span class="n">EnumA</span><span class="o">::</span><span class="mi">128</span><span class="o">:</span>
            <span class="k">return</span> <span class="mi">128</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">EnumA</span><span class="o">::</span><span class="mi">256</span><span class="o">:</span>
            <span class="k">return</span> <span class="mi">256</span><span class="p">;</span>
        <span class="k">default</span><span class="o">:</span>
            <span class="c1">// both cases listed below are valid and depend upon use case:</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">logic_error</span><span class="p">(</span><span class="s">&quot;Unknown EnumA&quot;</span><span class="p">);</span>

            <span class="c1">// OR</span>
            <span class="c1">// return 1;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Generally, for and while loops should be preferred over do while.
Iterators should have a meaningful name. C++11 provides for ( : )
syntax, which is preferred when working with containers; sometimes for
vectors indexed loops are better.</p>
<p>Loop statements shall be formatted with keywords on separate lines, as
follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">while</span> <span class="p">(</span><span class="n">predicate</span> <span class="o">&amp;&amp;</span> <span class="n">otherPredicate</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// do-while loops should be avoided</span>
<span class="k">do</span>
<span class="p">{</span>
    <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">predicate</span><span class="p">);</span>

<span class="k">for</span> <span class="p">(</span><span class="n">ClassName</span><span class="o">::</span><span class="n">iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">container</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">container</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">Type</span><span class="o">&amp;</span> <span class="nl">item</span> <span class="p">:</span> <span class="n">container</span><span class="p">)</span> <span class="c1">// C++11 range-based for loop</span>
    <span class="p">{</span>
        <span class="n">foo</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="comments">
<span id="header-n197"></span><h2>Comments<a class="headerlink" href="#comments" title="Permalink to this headline">¶</a></h2>
<p>Comments should be only used in appropriate situations. The best code is
self-documenting – focus rather on meaningful names rather than on
obvious comments.</p>
<p>When delivering code having dependency on another, not yet delivered
code, following code convention should be used:
[LTExxxx/LBTxxxx/Internal] TODO: reason, e.g.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// [LTE2464] TODO: uncomment when BM updates Info Model</span>
</pre></div>
</div>
<div class="section" id="logging-program-execution">
<span id="header-n201"></span><h3>Logging program execution<a class="headerlink" href="#logging-program-execution" title="Permalink to this headline">¶</a></h3>
<p>There are few functions/macros to make logs unified. The best way to log
program execution is using stream oriented API defined in file:
<code class="docutils literal notranslate"><span class="pre">C_Application\SC_OAM\OM_Common\Include\BtsOmLogStream.h</span></code>. The
benefits from using stream oriented API are:</p>
<ul class="simple">
<li><p>It’s type safe (as opposed to printf based solutions);</p></li>
<li><p>It’s easier to use (you don’t need to know if type is unsigned or not
and it’s size);</p></li>
<li><p>It’s easier to print complicated structures (one can define
<code class="docutils literal notranslate"><span class="pre">operator&lt;&lt;</span></code> for printing structures, enums and other types);</p></li>
</ul>
<p>Additionally it’s prints also source file where log is located and it
makes easier to analyse log.</p>
</div>
</div>
<div class="section" id="assertions">
<span id="header-n211"></span><h2>Assertions<a class="headerlink" href="#assertions" title="Permalink to this headline">¶</a></h2>
<div class="section" id="use-compile-time-assertions-instead-of-run-time-assertions">
<span id="header-n212"></span><h3>Use compile-time assertions instead of run-time assertions<a class="headerlink" href="#use-compile-time-assertions-instead-of-run-time-assertions" title="Permalink to this headline">¶</a></h3>
<p>Compile-time assertions or static assertions might prolong compilation
times, but improve run-time performance and reduce code complexity.
Further on compile-time assertions do not depend on code coverage and
are always guaranteed to be tested. So whenever failure conditions are
invariable, i.e. already testable at compile time, let the compiler do
the work for you.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">static_assert</span><span class="p">(</span><span class="mi">65535</span> <span class="o">&gt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">MyMsg</span><span class="p">));</span>
<span class="n">AaSysComMsgCreate</span><span class="p">(</span><span class="n">MY_MSG_ID</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">MyMsg</span><span class="p">),</span> <span class="n">destination</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="never-use-assert">
<span id="header-n215"></span><h3>Never use assert()<a class="headerlink" href="#never-use-assert" title="Permalink to this headline">¶</a></h3>
<p>When the expression passed as argument to assert() evaluates to false, a
message is written to the standard error device and abort is called to
terminate the application. In the context of BTSOM System Components,
messages written to standard error device do not get written to syslog
and thus are lost. Calling abort() raises a SIGABORT signal, being
handled in the CCS default signal handler. The call stack printed to
syslog before terminating does not include the location of the failing
assert(), but stops at the CCS signal handler. Thus a failing assert()
will leave no trace behind in syslog of the original cause for the
failing assert(). Only the SIGABORT signal and earlier logs will give a
hint that an assert() might have failed and what might have happened. As
NDEBUG is not defined for Release Builds this is not acceptable in the
field, but even in early test phases diagnosing failed assert() calls is
not straightforward. Thus usage of assert() is not allowed.</p>
</div>
<div class="section" id="never-use-aaerrorassert">
<span id="header-n217"></span><h3>Never use AaErrorAssert()<a class="headerlink" href="#never-use-aaerrorassert" title="Permalink to this headline">¶</a></h3>
<p>By macro AaErrorAssert() CCS provides an assertion macro that overcomes
the drawbacks of aforementioned standard assertion macro assert(). When
the expression passed to AaErrorAssert() evaluates to false, then the
failing expression and the complete call stack is written to syslog and
the application is aborted.</p>
<p><code class="docutils literal notranslate"><span class="pre">AaErrorAssert()</span></code> can be removed from executable at compilation time
by defining AAERROR<em>ASSERTION</em>DISABLED. As
AAERROR<em>ASSERTION</em>DISABLED is defined in all projects for release
builds, thus AaErrorAssert() is only present and effective for debug
builds. To avoid undefined behaviour in the field, removing such
assertions for release builds requires 100% scenario coverage when
testing debug builds, which cannot be guaranteed. It was even seen that
CI SCT regression (using release builds) passed, whereas SCT regression
on host (using debug builds) failed. This can only be explained by some
developers either running SCT regression for release builds or
committing without regression testing. To close these loopholes usage of
AaErrorAssert() is not allowed.</p>
</div>
<div class="section" id="never-use-assertions-where-error-handling-is-feasible">
<span id="header-n220"></span><h3>Never use assertions where error handling is feasible<a class="headerlink" href="#never-use-assertions-where-error-handling-is-feasible" title="Permalink to this headline">¶</a></h3>
<p>Every failing assertion causes a break in service availability and thus
impacts customer’s and consequently NSN’s revenue. Thus never use
assertions where error handling is feasible and service execution can
continue without any side effects.</p>
<p>Do not assert any data received over external interfaces. In such cases
error handling needs to take place. Interfaces to other system
components within OAM are considered to be extern.</p>
</div>
</div>
<div class="section" id="c-features">
<span id="header-n223"></span><h2>C++ Features<a class="headerlink" href="#c-features" title="Permalink to this headline">¶</a></h2>
<div class="section" id="classes">
<span id="header-n224"></span><h3>Classes<a class="headerlink" href="#classes" title="Permalink to this headline">¶</a></h3>
<div class="section" id="class-vs-struct">
<span id="header-n225"></span><h4>class vs. struct<a class="headerlink" href="#class-vs-struct" title="Permalink to this headline">¶</a></h4>
<p>Use a struct only for passive objects that carry data; everything else
is a class. The struct and class keywords behave almost identically in C++. We add
our own semantic meanings to each keyword, so you should use the
appropriate keyword for the data-type you’re defining. Structs should be used for passive objects that carry data, and may have
associated constants, but lack any functionality other than
access/setting the data members. The accessing/setting of fields is done
by directly accessing the fields rather than through method invocations.
Methods should not provide behavior but should only be used to set up
the data members, e.g., constructor, destructor, initialize(), reset(),
validate().</p>
<p>If more functionality is required, a class is more appropriate. If in
doubt, make it a class.</p>
</div>
<div class="section" id="interfaces">
<span id="header-n230"></span><h4>Interfaces<a class="headerlink" href="#interfaces" title="Permalink to this headline">¶</a></h4>
<p>Developers should pay extra care to create well-defined interfaces. It
is strongly recommended not to inherit from any concrete classes
containing complete implementation; when creating interfaces you should
follow ISP (Interface Segregation Principle). The destructor of an interface class shall be declared virtual and have
an empty implementation (see example below). A protected empty implementation of assignment operator is preferred in
order to prevent object slicing. Consider deriving from boost::noncopyable, as most classes inheriting
from interfaces should not be copyable. If you need copies, consider
adding a clone() method.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">oam</span>
<span class="p">{</span>

<span class="k">class</span> <span class="nc">IdManagement</span> <span class="o">:</span> <span class="k">private</span> <span class="n">boost</span><span class="o">::</span><span class="n">noncopyable</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">IdManagement</span><span class="p">()</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">handleMessage</span><span class="p">(</span><span class="n">message</span><span class="o">::</span><span class="n">IdAllocationReq</span><span class="o">*</span> <span class="n">message</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="n">IdManagement</span> <span class="o">&amp;</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">IdManagement</span><span class="o">&amp;</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="abstract-base-classes">
<span id="header-n236"></span><h4>Abstract base classes<a class="headerlink" href="#abstract-base-classes" title="Permalink to this headline">¶</a></h4>
<p>Abstract base classes are sometimes useful and can provide means for
much clearer implementation with an example of template method pattern.
They are also useful when it comes to remove duplication in some cases.</p>
</div>
<div class="section" id="deriving-from-base-classes">
<span id="header-n238"></span><h4>Deriving from base classes<a class="headerlink" href="#deriving-from-base-classes" title="Permalink to this headline">¶</a></h4>
<p>When derived class invokes a non-virtual method from its base, such
invocation shall not include explicit scope name to make name origin
clear, usage of explicit scope naming shall be used only when it is
necessary (multiple inheritance which should be avoided at all cost).
This also applies to non-virtual public member functions in the
interface implemented by a class.</p>
<p>It is required to use the “override” keyword in the derived class for
methods that are attempted to be overridden from the base class. Do not
use virtual, when override, as this is redundant information.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">bar</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">foo</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">fooImpl</span><span class="p">()</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">42</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
</div>
<div class="section" id="include-directives-usage">
<span id="header-n243"></span><h4>#include directives usage<a class="headerlink" href="#include-directives-usage" title="Permalink to this headline">¶</a></h4>
<p>Use <code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span></code> (brackets) when including header files into a translation
unit from C++ standard library. In all other cases, use “” (quotes).</p>
<p>Following order of includes is preferred. If not empty, each section
should be separated by a new line:</p>
<ul class="simple">
<li><p>library includes - provided by compiler for example or</p></li>
<li><p>3rd party library include – boost and others</p></li>
<li><p>external project library include – CCS libraries and others</p></li>
<li><p>Internal library include – libOM_utils and others.</p></li>
<li><p>this component includes</p></li>
</ul>
<p>As an exception to the rule, for source files first include shall always
be corresponding header file.</p>
<p>Full path to included header should always be specified, when your file
is located in the same directory as the file you are including prefer
using full path.</p>
<p>//source.cpp</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">“source.h”</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">“boost/bind.hpp”</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">“AaSysCom.hpp”</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">“CFsmBase.hpp”</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">“CellcRadParams.hpp”</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">“CELLC_CellSetupReq.hpp”</span><span class="cp"></span>
</pre></div>
</div>
</div>
<div class="section" id="forward-declaration">
<span id="header-n262"></span><h4>Forward declaration<a class="headerlink" href="#forward-declaration" title="Permalink to this headline">¶</a></h4>
<p>You can use forward declaration in an attempt to save on unnecessary
compilation. This section is based on [GoogleStd].</p>
<ul class="simple">
<li><p>Avoid forward declarations of entities defined in another project,
including 3rd parties libraries.</p></li>
<li><p>When using a class template, prefer to include its header file.</p></li>
<li><p>Don’t change value ownership into pointer ownership just so you can
use forward declaration.</p></li>
</ul>
</div>
</div>
<div class="section" id="undefined-and-unspecified-behaviour">
<span id="header-n271"></span><h3>Undefined and unspecified behaviour<a class="headerlink" href="#undefined-and-unspecified-behaviour" title="Permalink to this headline">¶</a></h3>
<p>C++ standard [Cpp99] differentiates undefined and unspecified behaviour.
No code shall rely on either one, even if with the specific compiler
version code works correctly.</p>
</div>
<div class="section" id="memset-vs-std-fill-n">
<span id="header-n273"></span><h3>memset vs std::fill_n<a class="headerlink" href="#memset-vs-std-fill-n" title="Permalink to this headline">¶</a></h3>
<p>Always use std::fill() or std::fill<em>n() to assign a specified value to
elements of a sequence, never use memset(). std::fill() and
std::fill</em>n() shall be used to assign a specified value to elements of
a sequence of any type. Where applicable value initialization shall be
used. See also chapter 6.3.2.</p>
<p>memset() can only be safely applied on PODs. Data structures might
change in future to non-PODs and bear the risk of undefined behaviour:</p>
<ul class="simple">
<li><p>Applying memset() on a class will overwrite the virtual table
pointer.</p></li>
<li><p>Applying memset() on a class will overwrite members already
initialized by default constructors. This double initialization at
least slows down performance and will cause more serious problems
when being applied e.g. on dynamic data members.</p></li>
</ul>
<p>Usage of std::fill_n() is future-safe.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">typedef</span> <span class="kt">int</span> <span class="n">A</span><span class="p">;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="k">const</span> <span class="n">numOfAs</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">A</span> <span class="n">someAs</span><span class="p">[</span><span class="n">numOfAs</span><span class="p">];</span>

    <span class="n">std</span><span class="o">::</span><span class="n">fill_n</span><span class="p">(</span><span class="n">someAs</span><span class="p">,</span> <span class="n">numOfAs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Second example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">A</span><span class="p">()</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">get</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">AConcrete</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">A</span><span class="p">()</span> <span class="o">:</span> <span class="n">i</span><span class="p">()</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">btsomLogger</span><span class="p">(</span><span class="n">LOG_DEBUG</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
        <span class="k">this</span><span class="o">-&gt;</span><span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">get</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="k">const</span> <span class="n">numOfAs</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="n">A</span> <span class="n">someAs</span><span class="p">[</span><span class="n">numOfAs</span><span class="p">];</span>
    <span class="n">std</span><span class="o">::</span><span class="n">fill_n</span><span class="p">(</span><span class="n">someAs</span><span class="p">,</span> <span class="n">numOfAs</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="always-use-value-initialization-to-set-memory-to-zero">
<span id="header-n285"></span><h3>Always use value initialization to set memory to zero<a class="headerlink" href="#always-use-value-initialization-to-set-memory-to-zero" title="Permalink to this headline">¶</a></h3>
<p>Always use value initialization with an empty initializer-list {} or
initialize () to set all members of a data structure to zero instead of
memset.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">S</span>
<span class="p">{</span>
    <span class="n">u32</span> <span class="n">u</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">S</span> <span class="n">s1</span> <span class="o">=</span> <span class="p">{};</span> <span class="c1">// initializes members of s1 to 0</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="n">s2</span><span class="p">(</span><span class="k">new</span> <span class="n">S</span><span class="p">());</span> <span class="c1">// initializes members of *s2 to 0</span>

<span class="k">class</span> <span class="nc">C</span>
<span class="p">{</span>
    <span class="n">C</span><span class="p">()</span>
        <span class="o">:</span> <span class="n">i</span><span class="p">()</span> <span class="c1">// same as memset(i, 0, sizeof(i)), only safer!</span>
    <span class="p">{</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="p">};</span>

<span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="mi">20</span><span class="p">]();</span> <span class="c1">// same as int* p = new int[20];</span>

<span class="c1">// memset(p, 0, 20*sizeof(int));</span>
<span class="c1">// ...but safer!</span>
</pre></div>
</div>
<p>Always use value initialized temporaries to reset data to zero.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">void</span> <span class="nf">reset</span><span class="p">(</span><span class="n">S</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">s</span> <span class="o">=</span> <span class="n">S</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p>For value initialized data, when a data structure changes to a non-POD,
e.g. by adding a class with a default constructor, the compiler will
automatically invoke such constructors and will apply correct value
initialization for other members.</p>
<p>Do not use memset() to 0 instead. As outlined in the previous chapter,
any usage of memset() is only safe for PODs.</p>
<blockquote>
<div><p>Note that compared to memset() there is no performance penalty when
using value initialization on PODs to initialize or reset data. If
applicable the compiler will generate the same code and will also
remove temporary objects.</p>
</div></blockquote>
</div>
<div class="section" id="never-use-memcpy-instead-of-copy-constructor">
<span id="header-n294"></span><h3>Never use memcpy() instead of copy constructor<a class="headerlink" href="#never-use-memcpy-instead-of-copy-constructor" title="Permalink to this headline">¶</a></h3>
<p>Always use copy constructors and assignment operators to copy from one
object to another. Always use std::copy() to copy one sequence to
another. Never use memcpy() for any of these purposes. Usage of memcpy() is only valid for PODs. But as data types might change
over time memcpy() is not future safe. For any non-POD having a non-trivial copy constructor or assignment
operator memcpy() will result in unspecified behaviour.</p>
<p>The following example will result into memory leaks and double freeing
of memory:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">A</span><span class="p">()</span>
        <span class="o">:</span> <span class="n">i</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">())</span>
    <span class="p">{</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="k">const</span> <span class="n">numOfAs</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="n">A</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">arr1</span><span class="p">[</span><span class="n">numOfAs</span><span class="p">],</span> <span class="n">arr2</span><span class="p">[</span><span class="n">numOfAs</span><span class="p">];</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="o">&amp;</span><span class="n">a1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">a2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">a1</span><span class="p">));</span> <span class="c1">// error!</span>
    <span class="n">memcpy</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr2</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">arr1</span><span class="p">));</span> <span class="c1">// error!</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The memory leaks and double freeing of allocated memory get avoided by
making use of assignment operators and std::copy() algorithm in the next
example. An assignment operator for class A has to be provided, as
std::unique_ptrs assignment operator is private:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">A</span><span class="p">()</span>
        <span class="o">:</span> <span class="n">i</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">())</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="n">A</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">A</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="o">*</span><span class="n">i</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">i</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">unsigned</span> <span class="k">const</span> <span class="n">numOfAs</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">A</span> <span class="n">a1</span><span class="p">,</span> <span class="n">a2</span><span class="p">,</span> <span class="n">arr1</span><span class="p">[</span><span class="n">numOfAs</span><span class="p">],</span> <span class="n">arr2</span><span class="p">[</span><span class="n">numOfAs</span><span class="p">];</span>
    <span class="n">a1</span> <span class="o">=</span> <span class="n">a2</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">arr1</span><span class="p">,</span> <span class="n">arr1</span> <span class="o">+</span> <span class="n">numOfAs</span><span class="p">,</span> <span class="n">arr2</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="alternative-operators">
<span id="header-n302"></span><h3>Alternative operators<a class="headerlink" href="#alternative-operators" title="Permalink to this headline">¶</a></h3>
<p>Using alternative operators such as not, or, and is up to developer.</p>
</div>
<div class="section" id="type-aliases-using-typedef">
<span id="header-n304"></span><h3>Type aliases – using, typedef<a class="headerlink" href="#type-aliases-using-typedef" title="Permalink to this headline">¶</a></h3>
<p>C++11 introduced new way of creating type aliases, which is more
readable especially for function pointers, also using alias-declaration
allows for creating template type aliases. The developer is free to use
either option.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">using</span> <span class="n">Integer</span> <span class="o">=</span> <span class="kt">int</span><span class="p">;</span> <span class="c1">//standard alias for normal type</span>
<span class="k">using</span> <span class="n">IntVector</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">// advantage of using - template type alias:</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="k">using</span> <span class="n">TemplatedVector</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="usage-of-standard-boost-and-other-libraries">
<span id="header-n308"></span><h3>Usage of Standard, Boost and other libraries<a class="headerlink" href="#usage-of-standard-boost-and-other-libraries" title="Permalink to this headline">¶</a></h3>
<p>Following algorithm should be applied to choose a solution providing the
required functionality:</p>
<ol class="arabic simple">
<li><p>Is it in the Standard C++ Library? Yes: great, use it! No: go to next
step.</p></li>
<li><p>Is it in the Boost library? Yes: great, use it! No: go to next step.</p></li>
<li><p>Is it in CC&amp;S Library? Yes: great, use it! No: go to next step.</p></li>
<li><p>Is it in some other library we have? Yes: great, use it! No: go to
next step.</p></li>
<li><p>Can we add a new library[1]? Yes: great, use it! No: go to next step.</p></li>
<li><p>Implement it yourself.</p></li>
</ol>
</div>
<div class="section" id="memory-management">
<span id="header-n323"></span><h3>Memory management<a class="headerlink" href="#memory-management" title="Permalink to this headline">¶</a></h3>
<p>It is advised to use stack allocated variables over the dynamic
allocated. Use dynamic allocation when necessary, and in such cases
avoid manual memory management with explicit calls to delete operator.
Instead, std::unique_ptr or std::shared_ptr shall be used wherever
possible.</p>
<p>This is to ensure that code is exception safe and does not introduce
memory leaks. Also, with dynamic allocation it is hard to track objects’
lifetime.</p>
<p>Transferring memory ownership between different parts of code shall be
explicitly included in the interface. For such cases, use source-sink
idiom (Source/sink idiom) with smart pointers. However,
std::shared_ptr should be preferred as it simplifies testing.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Untestable</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Untestable</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Dependency</span><span class="o">&gt;</span> <span class="n">dep</span><span class="p">)</span> <span class="o">:</span> <span class="n">dep</span><span class="p">(</span><span class="n">dep</span><span class="p">)</span>
    <span class="p">{}</span>

    <span class="c1">// other methods</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Testable</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Testable</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Dependency</span><span class="o">&gt;</span> <span class="n">dep</span><span class="p">)</span> <span class="o">:</span> <span class="n">dep</span><span class="p">(</span><span class="n">dep</span><span class="p">)</span>
    <span class="p">{}</span>

    <span class="c1">// other methods</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In the above example the first class takes ownership of the given
parameter. Therefore, passing Mock object to it is unreliable, as they
may be destroyed before checking the expectations. std::shared_ptrs can be created by constructing them from pointers
allocated using new operator or by using std::make_shared templated
function. The latter method is preferred as it is exception-safe and
improves performance of the created shared pointer [BSP45]. std::weak_ptr is a non-owning observer of an object owned by
std::shared_ptr and shall be used to avoid cyclic dependencies. Usage of std::unique_ptr should be limited to Private Implementation
Idiom [BSP45]. Usage of std::shared_array and boost::scoped_array is forbidden as
these are just C arrays with specified ownership and do not maintain its
size. Instead, use std::vector of std::unique_ptrs.</p>
</div>
<div class="section" id="type-casts">
<span id="header-n333"></span><h3>Type casts<a class="headerlink" href="#type-casts" title="Permalink to this headline">¶</a></h3>
<p>Explicit casting shall be avoided, use proper polymorphism instead.
Where necessary, prefer using C++ style casts [Cpp99] over old C-style
[CSt99]. This ensures proper semantics in all cases and introduces
additional checks for correctness. RTTI based casts should be avoided,
depend on the polymorphism, in some cases when it is not enough there
are patterns like visitor which serve purpose of avoiding RTTI based
casting.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Message</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Message</span><span class="p">()</span>
    <span class="p">{</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">acceptHandler</span><span class="p">(</span><span class="n">MessageHandler</span><span class="o">&amp;</span> <span class="n">handler</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">acceptHandlerImpl</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span>
    <span class="p">}</span>

<span class="k">protected</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">acceptHandlerImpl</span><span class="p">(</span><span class="n">MessageHandler</span><span class="o">&amp;</span> <span class="n">handler</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">ConcreteMessage</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Message</span>
<span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="n">acceptHandlerImpl</span><span class="p">(</span><span class="n">MessageHandler</span><span class="o">&amp;</span> <span class="n">handler</span><span class="p">)</span> <span class="k">override</span>
    <span class="p">{</span>
        <span class="n">Handler</span><span class="p">.</span><span class="n">handleMessage</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">Message</span><span class="o">*</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">receiveMessage</span><span class="p">();</span>
    <span class="n">MessageHandler</span> <span class="n">handler</span><span class="p">;</span>

    <span class="c1">// instead of handler-&gt;handleMessage(dynamic_cast&lt;ConcreteMessage*&gt;(msg));</span>
    <span class="n">msg</span><span class="o">-&gt;</span><span class="n">acceptHandler</span><span class="p">(</span><span class="n">handler</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Casting away const or volatile qualifiers must be justified, carefully
checked and documented properly. For such cases use const cast. When
necessary, conversions shall be stacked, instead of merging them in one
static or reinterpret cast.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">const</span> <span class="n">Foo</span><span class="o">*</span> <span class="n">foo</span><span class="p">;</span>
<span class="k">return</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">ConcreteFoo</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">const_cast</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">foo</span><span class="p">));</span>
</pre></div>
</div>
</div>
<div class="section" id="exceptions">
<span id="header-n339"></span><h3>Exceptions<a class="headerlink" href="#exceptions" title="Permalink to this headline">¶</a></h3>
<p>Exceptions shall inherit from one of the standard exceptions. For
application domain errors, use std::logic_error. Avoid using standard
exception classes directly, provide own exception class instead.</p>
<p>Function declaration shall not include exception specification.</p>
<p>When declaring public method that can throw some exception consider
naming it with a prefix of ‘try’ for example trySend, it will tell user
right away that this method can throw exception to its callers, it is in
hands of the user to check implementation to validate which exceptions
can be thrown. It is best to always throw maximum 1 kind of exception
from method.</p>
</div>
<div class="section" id="containers">
<span id="header-n343"></span><h3>Containers<a class="headerlink" href="#containers" title="Permalink to this headline">¶</a></h3>
<p>Prefer using standard containers over plain arrays or hand coded data
structures. Default containers are std::vector for sequences, std::set
for ordered sets of unique objects and std::map for key-value
dictionaries.</p>
<p>Implement own container class only if profiling shows a bottleneck which
cannot be resolved using standard library. While doing so, conform to
the standard as much as possible, including, but not limited to, correct
iterators tags and typedef exported by the container. This also applies
to const versions of exposed interfaces.</p>
<p>Even if creating a custom container, by default use standard containers
as the internal implementation. Avoid coding complex data structures by
hand (e.g. linked lists).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Key</span><span class="p">,</span> <span class="k">typename</span> <span class="n">Data</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Container</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">typedef</span> <span class="n">Data</span> <span class="n">data_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">Key</span> <span class="n">key_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">key_type</span><span class="p">,</span> <span class="n">data_type</span><span class="o">&gt;</span> <span class="n">value_type</span><span class="p">;</span>
    <span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">size_type</span><span class="p">;</span>

    <span class="k">class</span> <span class="nc">iterator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">iterator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">forward_iterator_tag</span><span class="p">,</span> <span class="n">value_type</span><span class="o">&gt;</span>
    <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">typedef</span> <span class="k">typename</span> <span class="n">Container</span><span class="o">::</span><span class="n">value_type</span> <span class="n">value_type</span><span class="p">;</span>

        <span class="n">iterator</span><span class="p">();</span>
        <span class="n">value_type</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">*</span><span class="p">();</span>
        <span class="n">iterator</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">++</span><span class="p">();</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">const_iterator</span> <span class="o">:</span> <span class="k">public</span> <span class="n">std</span><span class="o">::</span><span class="n">iterator</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">forward_iterator_tag</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">value_type</span><span class="o">&gt;</span>

    <span class="p">{</span>
        <span class="c1">// const iterator implementation</span>
    <span class="p">};</span>

    <span class="n">Container</span><span class="p">();</span>
    <span class="n">iterator</span> <span class="nf">begin</span><span class="p">();</span>
    <span class="n">const_iterator</span> <span class="nf">begin</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">iterator</span> <span class="nf">end</span><span class="p">();</span>
    <span class="n">const_iterator</span> <span class="nf">end</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">vValue</span><span class="p">);</span>
    <span class="n">iterator</span> <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">);</span>
    <span class="n">const_iterator</span> <span class="nf">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span>
    <span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">iterator</span> <span class="n">last</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">clear</span><span class="p">();</span>
    <span class="kt">bool</span> <span class="nf">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Note that iterators exposed by custom container provide standard
iterators tags, in order to enable optimization of standard algorithms
running on such a container.</p>
</div>
<div class="section" id="algorithms">
<span id="header-n349"></span><h3>Algorithms<a class="headerlink" href="#algorithms" title="Permalink to this headline">¶</a></h3>
<p>Generally, standard algorithms should be preferred over loops, like in
listing below:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;cctype&gt; // for toupper</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp"></span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot; hello &quot;</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Before: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// Before: hello</span>

    <span class="n">std</span><span class="o">::</span><span class="n">transform</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">s</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">toupper</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;After: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span> <span class="c1">// After: HELLO</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="functors">
<span id="header-n352"></span><h3>Functors<a class="headerlink" href="#functors" title="Permalink to this headline">¶</a></h3>
<p>When implementing own functors for standard algorithms, one shall
conform to Adaptable Function [STL] interface. Such a functor should
export certain types as typedefs. This is to enable higher order
manipulation of such functors, particularly function composition.</p>
<p>The easiest way to accomplish this is to derive the functor class from
std::unary<em>function or std::binary</em>function.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>class IsLowerCaseLetter : public std::unary_function&lt;bool, char&gt;
{
public:
  bool_type operator()(char_type char)
  {
      return (char &gt;= ‘a’) &amp;&amp; (char &lt;= ‘z’);
  }
};
</pre></div>
</div>
</div>
<div class="section" id="lambdas">
<span id="header-n356"></span><h3>Lambdas<a class="headerlink" href="#lambdas" title="Permalink to this headline">¶</a></h3>
<p>Lambdas were introduced in C++11 standard. They are useful in context of
standard algorithms when passing a user defined functor is needed:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="n">Point</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Point</span><span class="o">&gt;</span> <span class="n">V</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="n">Point</span><span class="p">());</span>
<span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">V</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">V</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="n">Point</span><span class="o">&amp;</span> <span class="n">P</span><span class="p">,</span> <span class="n">Point</span><span class="o">&amp;</span> <span class="n">Q</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">P</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">Q</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>
</div>
<p>Do not use lambdas in other context. Especially, do not define lambdas
greater than 5 lines. If needed, consider creating a named functor or
function object.</p>
<p>Do not use default captures, write all lambda captures explicitly. For
example, instead of <code class="docutils literal notranslate"><span class="pre">[=](int</span> <span class="pre">x)</span> <span class="pre">{</span> <span class="pre">return</span> <span class="pre">n</span> <span class="pre">+=</span> <span class="pre">x;</span> <span class="pre">}</span></code> use
<code class="docutils literal notranslate"><span class="pre">[n](int</span> <span class="pre">x)</span> <span class="pre">{</span> <span class="pre">return</span> <span class="pre">n+=x;</span> <span class="pre">}</span></code>. Before using lambda check if function
which you are trying to create does not already exists in the standard
library.</p>
</div>
<div class="section" id="const-usage">
<span id="header-n361"></span><h3>Const usage<a class="headerlink" href="#const-usage" title="Permalink to this headline">¶</a></h3>
<p>Use const whenever it makes sense:</p>
<ul class="simple">
<li><p>If an argument passed by reference or pointer to a function is not
modified, that argument should be const.</p></li>
<li><p>Class method should be const if it does not change inner state of an
object, i.e. does not modify data members, does not call any
non-const method and do not return a non-const pointer or non-const
reference to a data member.</p></li>
<li><p>Class data members should be const if they are not modified after
creation.</p></li>
</ul>
</div>
<div class="section" id="inline-functions">
<span id="header-n370"></span><h3>Inline functions<a class="headerlink" href="#inline-functions" title="Permalink to this headline">¶</a></h3>
<p>Adding inline keyword to the function will almost never change anything,
as it is only a hint for compiler. Inline should only be used for
template methods declared outside the class (in the same header file).
Inline keyword is applicable when defining methods in the header file
outside of the class definition.</p>
</div>
<div class="section" id="explicit-constructors">
<span id="header-n372"></span><h3>Explicit constructors<a class="headerlink" href="#explicit-constructors" title="Permalink to this headline">¶</a></h3>
<p>Use the C++ keyword explicit for constructors callable with one argument
to avoid undesirable auto conversions.</p>
</div>
<div class="section" id="static-usage">
<span id="header-n374"></span><h3>Static usage<a class="headerlink" href="#static-usage" title="Permalink to this headline">¶</a></h3>
<p>Static keyword has different semantics depending on the place it is used
in:</p>
<ul class="simple">
<li><p>Methods which do not access data member and do not call any
non-static method should be static. Those methods can be treated in
common sense as utils methods. Keep in mind that often these kinds of
methods does not belong to this class and is often a good reason to
try to move them somewhere else.</p></li>
<li><p>Static local variable has a scope of visibility limited to function
it is declared, however it has a lifespan extended after function
returns. Usage of static local should be avoided and has no place in
the OO code.</p></li>
<li><p>Static data members have scope of a class and lifespan of global
object. Do not use static members other than POD, because the order
of creation of static members and global variables is undefined. So
the order of destruction is undetermined, and destruction of one
non-POD static variable depending on other may cause program crashes
(e.g. in multithreaded environment).</p></li>
<li><p>Use static for global variable to limit its name scope to the cpp
file it is defined.</p></li>
</ul>
</div>
<div class="section" id="function-parameter-order">
<span id="header-n385"></span><h3>Function parameter order<a class="headerlink" href="#function-parameter-order" title="Permalink to this headline">¶</a></h3>
<p>Argument order of a function is inputs and then outputs. Output
parameters are strongly discouraged.</p>
</div>
<div class="section" id="ternary-operator">
<span id="header-n387"></span><h3>Ternary operator<a class="headerlink" href="#ternary-operator" title="Permalink to this headline">¶</a></h3>
<p>Using ternary operator is advisable instead of if-else one liners, only
when statement results in the same behavior. Do not use the ternary
operator as a hack around Allman.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="kt">int</span> <span class="nf">abs</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="nl">n</span> <span class="p">:</span> <span class="o">-</span><span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="header-n391">
<span id="idioms-and-design-patterns"></span><h2>Idioms and design patterns<a class="headerlink" href="#header-n391" title="Permalink to this headline">¶</a></h2>
<div class="section" id="resource-acquisition-is-initialization">
<span id="header-n392"></span><h3>Resource Acquisition Is Initialization<a class="headerlink" href="#resource-acquisition-is-initialization" title="Permalink to this headline">¶</a></h3>
<p>All resources should be wrapped in a class, which allocates the resource
in its constructor, and releases it in the destructor. This ensures
proper release of the resource in case of an early return from a
function or exception being thrown from its body.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>class File : private boost::noncopyable
{
public:
    explicit File(const std::string&amp; name)
        : name(name)
    {
        fd = open(name.c_str(), O_CREAT, S_IREAD | S_IWRITE);

        if (fd &lt;= 0)
        {
            throw std::logic_error(&quot;Could not open file ‘&quot; + name + &quot;’&quot;);
        }
    }

    ~File()
    {
        close(fd);
        unlink(name);
    }

private:
    int fd;
};

void frobnicate()
{
    // temporary file
    File file(&quot; temp.txt&quot;);

    while (...)
    {
        if (logicFailed())
        {
            // thanks to RAII, file resources will be released
            throw std::runtime_excpetion(“logic failed”);
        }
    }
}
</pre></div>
</div>
<p>In case of heap allocated objects, one should use smart pointer to
handle memory. This is especially useful in Factory Methods utilizing
Builder pattern [GHJV95], i.e. when one needs to do non-trivial
initialization of a heap-allocated object outside its constructor.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">createObject</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Object</span><span class="o">&gt;</span> <span class="n">object</span><span class="p">(</span><span class="k">new</span> <span class="n">Object</span><span class="p">());</span>
    <span class="c1">// if one of these fails, memory is released</span>

    <span class="n">object</span><span class="o">-&gt;</span><span class="n">initializeFirst</span><span class="p">();</span>
    <span class="n">object</span><span class="o">-&gt;</span><span class="n">initializeSecond</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">object</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="header-n398">
<span id="id1"></span><h3>Interfaces<a class="headerlink" href="#header-n398" title="Permalink to this headline">¶</a></h3>
<p>For most of cases plain interface with all virtual non-static method and
without members or implementation is preferred. Virtual destructor with
empty inline implementation is advised for such interfaces, do not
declare the virtual destructors as pure virtual = 0, as it forces users
to provide their own implementation of destructors even when it will be
empty.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">Value</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Value</span><span class="p">()</span>
    <span class="p">{}</span>

    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">calculate</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Interfaces shall appear at the top of class hierarchy, it is not
recommended inherit one interface from another. Multiple inheritance is
allowed only from interfaces and, as an exception, CRTP and policy
classes.</p>
<p>Note that once member function is made virtual in the base class, it
stays virtual in the whole hierarchy. Therefore, one shall add override
keyword to respective member functions in all derived classes, in order
to emphasize function’s origin and to rely on compiler in case of any
typos.</p>
<p>Pay extra attention to make derived classes satisfy Liskov substitution
principle ([LW99], section 5). In cases where such a relationship is not
clear and/or hard to explain, prefer aggregation over inheritance and
forward selected calls to the aggregated object.</p>
</div>
<div class="section" id="crtp">
<span id="header-n404"></span><h3>CRTP<a class="headerlink" href="#crtp" title="Permalink to this headline">¶</a></h3>
<p>Curiously Recurring Template Pattern (CRTP) is a construct where a class
inherits from template instantiated with the class as a parameter, as
follows:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">ThisIsCrtp</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">User</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ThisIsCrtp</span><span class="o">&lt;</span><span class="n">User</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This idiom uses inheritance in a non-orthodox way, in order to inject
some code into the derived class. Such cases are not considered
interfaces and interface naming rules do not apply. That being said, it
is strongly encouraged to find a meaningful name, instead of just adding
a generic “Base” suffix.</p>
<p>Multiple inheritance from CRTP templates is allowed, but using them as a
“normal” base class to e.g. take an argument to a function is forbidden.</p>
</div>
<div class="section" id="source-sink">
<span id="header-n409"></span><h3>Source/sink<a class="headerlink" href="#source-sink" title="Permalink to this headline">¶</a></h3>
<p>Transferring memory ownership is a common case in message-based
architectures. Such semantics is directly supported in the C++ language
itself by means of std::unique_ptr template class.</p>
<p>In order to use the idiom, one needs to explicitly declare which class
allocates memory (or some other resource) and which one releases it.
This has to be decided upfront and should not be changed.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MessageReceiver</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span> <span class="n">receiveMessage</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span> <span class="n">msg</span><span class="p">;</span>

        <span class="c1">// do some logic to fill in msg</span>

        <span class="n">msg</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Message</span><span class="p">(...);</span>
        <span class="k">return</span> <span class="n">msg</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">MessageHandler</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="c1">// note passing auto pointer by value and no explicit release</span>

    <span class="kt">void</span> <span class="n">handleMessage</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span> <span class="n">msg</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// do some logic to interpret message contents</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Such implementation ensures that ownership of the message is transferred
safely and there are no memory leaks, i.e. when exception is thrown by
MessageHandler logic.</p>
</div>
<div class="section" id="policy-classes-and-type-traits">
<span id="header-n414"></span><h3>Policy classes and type traits<a class="headerlink" href="#policy-classes-and-type-traits" title="Permalink to this headline">¶</a></h3>
<p>Policy and trait classes are used in generic and generative programming
[Ale01] as a way to achieve static polymorphism of a template code. Such
class shall have a Policy or Traits suffix, depending on the actual
functionality.</p>
<p>Trait classes are class templates parameterized by a single type,
containing a set of constants and operations connected and describing a
type, regardless where the type is used. Using such a class in a generic
code instead of hard-coded calls enables greater flexibility and allows
user to adapt the code easily. Such classes usually have all members
public, so it is advised to declare them with a struct.</p>
<p>Note that in the following example RAII idiom is also used for exception
safety.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">LockType</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="n">LockTraits</span><span class="p">;</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">LockType</span> <span class="o">=</span> <span class="n">pthread_mutex_t</span><span class="o">&gt;</span>
<span class="k">class</span> <span class="nc">Safe</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">put</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">typename</span> <span class="n">LockTraits</span><span class="o">&lt;</span><span class="n">LockType</span><span class="o">&gt;::</span><span class="n">ScopeLock</span> <span class="n">lock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">T</span> <span class="n">get</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">typename</span> <span class="n">LockTraits</span><span class="o">&lt;</span><span class="n">LockType</span><span class="o">&gt;::</span><span class="n">ScopeLock</span> <span class="n">lock</span><span class="p">(</span><span class="n">lock</span><span class="p">);</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">LockType</span> <span class="n">lock</span><span class="p">;</span>
    <span class="n">T</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="n">LockTraits</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">class</span> <span class="nc">ScopeLock</span> <span class="o">:</span> <span class="k">private</span> <span class="n">boost</span><span class="o">::</span><span class="n">noncopyable</span>
    <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">ScopeLock</span><span class="p">(</span><span class="n">Mutex</span><span class="o">&amp;</span> <span class="n">mutex</span><span class="p">)</span>
            <span class="o">:</span> <span class="n">mutex</span><span class="p">(</span><span class="n">mutex</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">pthread_mutex_lock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">mutex</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="o">~</span><span class="n">ScopeLock</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">pthread_mutex_unlock</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lock</span><span class="p">.</span><span class="n">mutex</span><span class="p">);</span>
        <span class="p">}</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">Mutex</span><span class="o">&amp;</span> <span class="n">mutex</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="n">LockTraits</span><span class="o">&lt;</span><span class="n">Semaphore</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">class</span> <span class="nc">ScopeLock</span> <span class="o">:</span> <span class="k">private</span> <span class="n">boost</span><span class="o">::</span><span class="n">noncopyable</span>
    <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">ScopeLock</span><span class="p">(</span><span class="n">Semaphore</span><span class="o">&amp;</span> <span class="n">sem</span><span class="p">)</span>
            <span class="o">:</span> <span class="n">sem</span><span class="p">(</span><span class="n">sem</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">sem_wait</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="o">~</span><span class="n">ScopeLock</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">sem_post</span><span class="p">(</span><span class="o">&amp;</span><span class="n">sem</span><span class="p">);</span>
        <span class="p">}</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="n">Semaphore</span><span class="o">&amp;</span> <span class="n">sem</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Policy classes, on the other hand, allow modification of generic code
that uses them, as a well-defined extension points. This effectively
implements compile-time Strategy design pattern [GHJV95]. Note that
great attention must be paid while defining policies, especially when
generic code uses multiple policies, as they should be orthogonal and
the code should support all possible combinations. If this is not
possible and some policy sets are mutually exclusive, one should use
static assertion to stop the compilation with a meaningful message.</p>
<p>For details, refer to [Ale01], as the topic is too complicated to
include it in a coding standard document.</p>
</div>
<div class="section" id="private-implementation-pimpl">
<span id="header-n422"></span><h3>Private Implementation (pImpl)<a class="headerlink" href="#private-implementation-pimpl" title="Permalink to this headline">¶</a></h3>
<p>Dependencies between different parts of the code shall be kept minimal.
This applies particularly to extensive use of templates and generic
code, when including a lot of header files can lead to very long
compilation times.</p>
<p>One way to limit internal dependencies is to hide class implementation
in so-called private implementation class. This ensures that only public
interface of the class is exposed, and all private members are
completely unknown to the user, but requires the developer to ensure
proper construction and copying of the internal object.</p>
<p>Note that while this idiom significantly improves encapsulation, it has
some impact on performance and introduces large maintenance overhead.
Therefore it shall only be used in case of stable classes that are
unlikely to change during refactoring.</p>
<p>One should also pay extra attention to proper copying of the data. For
clarity, this issue is avoided in the example by making the class
non-copyable.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#pragma once</span>

<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">“boost / utility.hpp”</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">“Message.hpp”</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">coding</span>
<span class="p">{</span>
<span class="k">class</span> <span class="nc">QueueImpl</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Queue</span> <span class="o">:</span> <span class="k">private</span> <span class="n">boost</span><span class="o">::</span><span class="n">noncopyable</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Element</span><span class="o">&gt;</span> <span class="n">ElementPtr</span><span class="p">;</span>

    <span class="n">Queue</span><span class="p">();</span>
    <span class="n">Queue</span><span class="p">(</span><span class="k">const</span> <span class="n">Queue</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">);</span>
    <span class="n">ElementPtr</span> <span class="nf">pop</span><span class="p">();</span>
    <span class="kt">void</span> <span class="nf">push</span><span class="p">(</span><span class="n">ElementPtr</span> <span class="n">element</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">QueueImpl</span><span class="o">&gt;</span> <span class="n">impl</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp">#include</span> <span class="cpf">“Queue.h”</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">&lt;queue&gt;</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">“Mutex.hpp”</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">coding</span>
<span class="p">{</span>
<span class="c1">// hide implementation details in cpp file</span>

<span class="k">class</span> <span class="nc">QueueImpl</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">Queue</span><span class="o">::</span><span class="n">ElementPtr</span> <span class="n">pop</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Queue</span><span class="o">::</span><span class="n">ElementPtr</span> <span class="n">element</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
        <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">();</span>

        <span class="k">return</span> <span class="n">element</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">push</span><span class="p">(</span><span class="n">Queue</span><span class="o">::</span><span class="n">ElementPtr</span> <span class="n">element</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">queue</span><span class="p">.</span><span class="n">push</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
    <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">queue</span><span class="o">&lt;</span><span class="n">ElementPtr</span><span class="o">&gt;</span> <span class="n">queue</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// ensure proper construction</span>

<span class="n">Queue</span><span class="o">::</span><span class="n">Queue</span><span class="p">()</span>
    <span class="o">:</span> <span class="n">impl</span><span class="p">(</span><span class="k">new</span> <span class="n">QueueImpl</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="n">Queue</span><span class="o">::</span><span class="n">Queue</span><span class="p">(</span><span class="k">const</span> <span class="n">Queue</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">impl</span><span class="p">(</span><span class="k">new</span> <span class="n">QueueImpl</span><span class="p">(</span><span class="o">*</span> <span class="n">rhs</span><span class="p">.</span><span class="n">impl</span><span class="p">))</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="c1">// forward call to internal implementation</span>

<span class="n">Queue</span><span class="o">::</span><span class="n">ElementPtr</span> <span class="n">Queue</span><span class="o">::</span><span class="n">pop</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">impl</span><span class="o">-&gt;</span><span class="n">pop</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Queue</span><span class="o">::</span><span class="n">push</span><span class="p">(</span><span class="n">ElementPtr</span> <span class="n">element</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">impl</span><span class="o">-&gt;</span><span class="n">push</span><span class="p">(</span><span class="n">element</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="filesystem-system-interactions-dependency-injection">
<span id="header-n430"></span><h3>Filesystem, system interactions – Dependency Injection<a class="headerlink" href="#filesystem-system-interactions-dependency-injection" title="Permalink to this headline">¶</a></h3>
<p>When working with file system or system commands, it’s best to use
dedicated classes. Please study the following example, where production
class MessageHandler has to read file contents and then execute a system
command. Thanks to the dedicated classes like BtsOmCommand and
FileAccess we can freely stub the behavior of system in our unit tests.
Note that BtsOmCommand and FileAccess classes are just examples.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>#pragma once
#include “BtsOmCommand.h”
#include “FileAccess.h”

class MessageHandler
{
public:
    MessageHandler(std::unique_ptr&lt;BtsOmCommand&gt; command,
                   std::unique_ptr&lt;FileAccess&gt; fileAccess)
      : command(command), fileAccess(fileAccess)

   {
   }

   void execute()
   {
       std::string fileContents = fileAccess-&gt;readContent(“file.txt”);
       if (fileContents == “Valid”)
       {
           command-&gt;move(“file.txt”, “valid.txt”);
       }
       else
       {
           command-&gt;removeForce(“file.txt”);
           throw std::logic_error(“Unexpected file contents”);
       }
   }
};
</pre></div>
</div>
</div>
<div class="section" id="smart-pointers-pointers-and-references-when-to-use">
<span id="header-n433"></span><h3>Smart pointers, pointers and references – when to use?<a class="headerlink" href="#smart-pointers-pointers-and-references-when-to-use" title="Permalink to this headline">¶</a></h3>
<p>Use smart pointers to inform users about pointer ownership. Type of
pointer should carry important information to the user. A raw pointer
should tell that the pointer will be deleted somewhere else, unique
pointer should tell user that he is to take care of memory cleanup, and
lastly, shared pointer tells that you want to participate in keeping the
object alive.</p>
<p>For function parameters, in most cases you should still use raw pointers
or, preferably, references. Use raw pointer over references only when
you want to handle nullptr case. Prefer raw pointers and references in
parameters over smart pointers unless you want to take care of the
ownership of the object. It’s okay to use .get() or dereference the
smart pointer instead of polluting the interfaces with smart pointers.</p>
<p>Guideline on way of passing the function parameters:</p>
<ul class="simple">
<li><p>by value: function uses copy of argument</p></li>
<li><p>by reference: function does not participate in ownership (cannot
handle nullptr)</p></li>
<li><p>by pointer: function does not participate in ownership (can handle
nullptr)</p></li>
<li><p>by unique pointer: function gets ownership of this object</p></li>
<li><p>by shared pointer: function wants to take part in ownership and can
store it for further use</p></li>
</ul>
<p>When returning pointers from functions use similar guidelines: return
smart pointers to indicate memory ownership and raw pointers just to
give the client access to particular object without transferring
ownership. For example, factory methods usually should return
unique_ptrs, but situation may differ depending on the use case. Watch
[CCon14] and read [CppCore] for details.</p>
</div>
</div>
<div class="section" id="refactoring">
<span id="header-n449"></span><h2>Refactoring<a class="headerlink" href="#refactoring" title="Permalink to this headline">¶</a></h2>
<p>This chapter contains information to help you decide when to consider
refactoring. It lists some known code smells. For the sake of good
practice, the list below should also be considered when writing new
code.</p>
<ol class="arabic simple">
<li><p>Method / function length – shorter functions are preferred to larger ones (empty lines or curly braces are not counted):</p>
<ol class="arabic simple">
<li><p>0-10: perfect</p></li>
<li><p>10-20: should be considered for refactoring</p></li>
<li><p>20+: poor, shall be considered for refactoring</p></li>
</ol>
</li>
<li><p>Duplicate code:</p>
<ol class="arabic simple">
<li><p>more than 40% of one method is copied to another method</p></li>
<li><p>obvious cases of duplicate code across methods and classes</p></li>
<li><p>use the Sonar and CPD (Copy/Paste Detector) tools on Jenkins to easily check code duplication</p></li>
</ol>
</li>
<li><p>Parameter list length:</p>
<ol class="arabic simple">
<li><p>0-2: perfect</p></li>
<li><p>3-4: acceptable</p></li>
<li><p>5+: consider split function into few or (less preferred) the use of structures or classes as parameter types, or builder pattern</p></li>
</ol>
</li>
<li><p>Wrong usage of comments:</p>
<ol class="arabic simple">
<li><p>if comments are obvious, remove them</p></li>
<li><p>if algorithm is complicated, describe it explicitly; it is up to the developer to either provide text or a DOORS reference</p></li>
<li><p>method implementation requires too many comments</p></li>
<li><p>change comment to named object: function, variable or constant</p></li>
</ol>
</li>
<li><p>Conditional complexity (number of conditions as part of a conditional statement) – low complexity functions are preferred:</p>
<ol class="arabic simple">
<li><p>0-2 conditions: perfect</p></li>
<li><p>3-4 conditions: acceptable</p></li>
<li><p>5-6 conditions: time to consider writing a new method for this condition</p></li>
<li><p>7+ conditions: list of arguments is too long</p></li>
</ol>
</li>
<li><p>Large classes – “god Objects”:</p>
<ol class="arabic simple">
<li><p>classes that hold multiple responsibilities</p></li>
</ol>
</li>
<li><p>Inappropriate Intimacy:</p>
<ol class="arabic simple">
<li><p>class uses implementation details of another class (except UTs)</p></li>
</ol>
</li>
<li><p>Poorly named methods or members:</p>
<ol class="arabic simple">
<li><p>name does not follow lowerCamelCase</p></li>
<li><p>name uses not well known or unnecessary abbreviations (please write
config instead of cnfg)</p></li>
<li><p>name is too long (see chapter 2.6 for details)</p></li>
<li><p>type is embedded in the name</p></li>
<li><p>inconsistent method names (e.g. if a function open() is defined, then its opposite should be named close())</p></li>
</ol>
</li>
<li><p>Dead code:</p>
<ol class="arabic simple">
<li><p>remove commented out code</p></li>
</ol>
</li>
<li><p>Too many primitive type members:</p>
<ol class="arabic simple">
<li><p>try to find out if some members are closely related and encapsulate
them into a separate class / structure</p></li>
</ol>
</li>
<li><p>Broken Liskov substitution principle:</p>
<ol class="arabic simple">
<li><p>overridden methods break contact with the inherited class, therefore objects of the derived class cannot be used in place of objects of
the inherited class; to fix this, consider aggregation instead of
inheritance</p></li>
</ol>
</li>
<li><p>Nested conditions:</p>
<ol class="arabic simple">
<li><p>0-1: Perfrect</p></li>
<li><p>2: acceptable</p></li>
<li><p>3+: move most nested conditions to new function</p></li>
</ol>
</li>
</ol>
</div>
<div class="section" id="testing-ut">
<span id="header-n584"></span><h2>Testing - UT<a class="headerlink" href="#testing-ut" title="Permalink to this headline">¶</a></h2>
<p>For existing component all new unit tests should be designed and written
using GTest/GMock framework. During development of new component some
other framework could be used, if there is a good enough reason to do
so.</p>
<div class="section" id="strategy">
<span id="header-n586"></span><h3>Strategy<a class="headerlink" href="#strategy" title="Permalink to this headline">¶</a></h3>
<p>The main testing strategy to be used in OAM is black box testing. This
means that one should focus on testing public interface of a
class/service. No macros #define protected public are allowed.</p>
<p>Although not recommended, it might be necessary to extend the test case
with white box testing in order to achieve sufficient code coverage. One
shall do that by modifying code under test to expose members as
protected and implement a testable version of the original class.
Exposed members can only be accessed using getters returning by value
and setters:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">namespace</span> <span class="n">cellp</span>
<span class="p">{</span>
<span class="k">class</span> <span class="nc">CellManagement</span>
<span class="p">{</span>
    <span class="c1">// note the full scope to avoid ambiguity</span>

<span class="k">protected</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">state</span><span class="p">;</span>
    <span class="c1">// application code follows</span>
<span class="p">};</span>
<span class="p">}</span>

<span class="c1">// test code</span>

<span class="k">namespace</span> <span class="n">cellp</span>
<span class="p">{</span>

<span class="k">class</span> <span class="nc">TestableCellManagement</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CellManagement</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">getState</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">state</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">setState</span><span class="p">(</span><span class="kt">int</span> <span class="n">newState</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">state</span> <span class="o">=</span> <span class="n">newState</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Aside from such declarations it is forbidden to pollute application code
with sections related to unit tests.</p>
</div>
<div class="section" id="structure">
<span id="header-n591"></span><h3>Structure<a class="headerlink" href="#structure" title="Permalink to this headline">¶</a></h3>
<p>Each class should have its own unit test. It is recommended to put unit
tests for each class in a separate compilation unit. However if two or
more classes provide similar functionality it is allowed to provide one
test set for all of them.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">class</span> <span class="nc">MessageReceiverTestSuite</span> <span class="o">:</span> <span class="n">testing</span><span class="o">::</span><span class="n">Test</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">MessageReceiverTestSuite</span><span class="p">();</span> <span class="c1">// optional constructor</span>
    <span class="o">~</span><span class="n">MessageReceiverTestSuite</span><span class="p">();</span> <span class="c1">// optional destructor</span>

    <span class="kt">void</span> <span class="nf">SetUp</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span> <span class="c1">// optional setup</span>
    <span class="kt">void</span> <span class="nf">TearDown</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span> <span class="c1">// optional teardown</span>
    <span class="kt">void</span> <span class="nf">helper</span><span class="p">();</span> <span class="c1">// optional helper methods</span>
<span class="p">};</span>

<span class="n">TEST_F</span><span class="p">(</span><span class="n">MessageReceiverTestSuite</span><span class="p">,</span> <span class="n">shouldFailWhenGivenUnexpectedEvent</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// testing code</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Each test should be registered using TEST<em>F macro provided by Google
Test, TEST macro if no fixture is required or TEST</em>P for parameterized
tests.</p>
</div>
<div class="section" id="pre-conditions-and-post-conditions">
<span id="header-n595"></span><h3>Pre-conditions and post-conditions<a class="headerlink" href="#pre-conditions-and-post-conditions" title="Permalink to this headline">¶</a></h3>
<p>Common initialization code, including preconditions, method shall be
implemented within the test constructor or SetUp() method. TearDown()
method or destructor, on the other hand, shall release all resources
allocated in either SetUp() or test case itself. It is strongly
recommended to perform all actions which are required to leave the
environment in a state as it was before test case, this may include
clearing singleton instances.</p>
<p>It is forbidden to reuse other test cases as preconditions. If few test
has the same preconditions it should be provided by some function. If
one test can be run only, when other was executed before one can merge
this testecases into one test.</p>
<p>Note that it might be necessary to enable white box testing in a
particular piece of code to simplify unit test. This is especially valid
for state machines, where access to private members allows the test to
set desired state directly, without going through declared flow.
Enabling white box testing is assumed better than reusing test cases as
preconditions.</p>
</div>
<div class="section" id="logging-test-execution">
<span id="header-n599"></span><h3>Logging test execution<a class="headerlink" href="#logging-test-execution" title="Permalink to this headline">¶</a></h3>
<p>While GTest provides basic functionality to generate test execution log,
one might need to put additional debug logs, especially if the test case
is non-trivial. Such logs shall be generated using the same
stream–oriented API as in application logs. There is possibility to run
tests with printing logs.. It would be best however that the tests be
simple enough to localise the problem without such logs.</p>
</div>
<div class="section" id="unit-tests-vs-system-component-tests-sct">
<span id="header-n601"></span><h3>Unit tests vs. System Component Tests (SCT)<a class="headerlink" href="#unit-tests-vs-system-component-tests-sct" title="Permalink to this headline">¶</a></h3>
<p>The differences between SCTs and UTs are defined in order to avoid
overlapping, which would increase required maintenance. The main
difference is the fact that SCTs run on the whole, unmodified, system
component, while unit tests are executed on the parts of code, with rest
simulated with mocks.</p>
<p>Also, SCT cases shall have direct mapping to use cases described in
functional specification documents. Unit tests, on the other hand, shall
not interact with the real platform (CC&amp;S), as they can be isolated
using proper stubs. Unit tests shall neither send nor receive any
messages from SC’s external interface.</p>
<p>UT code shuld be treated as production code, means all described rules
and good practices apply to them unless explicity stated otherwise.</p>
</div>
<div class="section" id="header-n605">
<span id="id2"></span><h3>Refactoring<a class="headerlink" href="#header-n605" title="Permalink to this headline">¶</a></h3>
<p>One of the goals of unit testing is to protect the developer during
refactoring. Therefore unit tests should never be disabled while
refactoring production code.</p>
<p>A simple example of an approach of class and unit test extraction:</p>
<ol class="arabic simple">
<li><p>Introduce a factory for the original class in the production code,</p></li>
<li><p>Verify that integration tests (SCTs) pass,</p></li>
<li><p>Extract the methods and members into a new class and replace the
relevant code with uses of the extracted class methods (do not modify
the tests!),</p></li>
<li><p>Verify that unit tests pass,</p></li>
<li><p>Use Dependency Injection to inject the extracted class into the
original,</p></li>
<li><p>Verify that the whole regression passes,</p></li>
<li><p>Cover the extracted class with characterization tests,</p></li>
<li><p>Replace the extracted class with a Mock Object in the original tests
(do not modify the production code),</p></li>
<li><p>Verify that unit tests pass.</p></li>
</ol>
</div>
<div class="section" id="naming-convention">
<span id="header-n627"></span><h3>Naming convention<a class="headerlink" href="#naming-convention" title="Permalink to this headline">¶</a></h3>
<div class="section" id="unit-test-files-tests">
<span id="header-n628"></span><h4>Unit Test Files – Tests<a class="headerlink" href="#unit-test-files-tests" title="Permalink to this headline">¶</a></h4>
<p>Unit test filenames shall correspond to the name of file being tested,
with additional Test suffix, e.g. MessageSenderTest.cpp. Unit test shall
consist of the implementation file only, as headers for test suites are
not needed.</p>
<p>As to location follow convention in the project.</p>
</div>
<div class="section" id="unit-test-files-test-doubles">
<span id="header-n631"></span><h4>Unit Test Files – Test Doubles<a class="headerlink" href="#unit-test-files-test-doubles" title="Permalink to this headline">¶</a></h4>
<p>Unit test doubles [Doubles] for a specific part of the code shall be
stored in the Doubles directory UT/Doubles/Include and UT/Doubles/Source
directory, mimicking directory structure of production code. That is,
mock for class Include/namespace/Class.h should have its Mock located in
UT/Doubles/Include/namespace/ClassMock.h. There shouldn’t be separate
directories for different Test Doubles, as in Stubs Dummies etc, each
should go into the same directory as class being Doubled.</p>
<p>All test doubles should be inside appropriate Doubles directory relative
to the original class that is being mocked e.g.:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SC_OAM</span><span class="o">/</span><span class="n">OM_PIL</span><span class="o">/</span><span class="n">Include</span><span class="o">/</span><span class="n">BS</span><span class="o">.</span><span class="n">h</span>
<span class="n">SC_OAM</span><span class="o">/</span><span class="n">OM_PIL</span><span class="o">/</span><span class="n">UT</span><span class="o">/</span><span class="n">Doubles</span><span class="o">/</span><span class="n">Include</span><span class="o">/</span><span class="n">BsMock</span><span class="o">.</span><span class="n">h</span>
</pre></div>
</div>
<p>Nested directories example:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">SC_OAM</span><span class="o">/</span><span class="n">OM_PIL</span><span class="o">/</span><span class="n">Include</span><span class="o">/</span><span class="n">enbc</span><span class="o">/</span><span class="n">types</span><span class="o">/</span><span class="n">Nested</span><span class="o">.</span><span class="n">h</span>
<span class="n">SC_OAM</span><span class="o">/</span><span class="n">OM_PIL</span><span class="o">/</span><span class="n">UT</span><span class="o">/</span><span class="n">Doubles</span><span class="o">/</span><span class="n">Include</span><span class="o">/</span><span class="n">enbc</span><span class="o">/</span><span class="n">types</span><span class="o">/</span><span class="n">NestedMock</span><span class="o">.</span><span class="n">h</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="test-suites">
<span id="header-n637"></span><h3>Test suites<a class="headerlink" href="#test-suites" title="Permalink to this headline">¶</a></h3>
<p>All test suites shall mimic the namespaces where original class are
located.</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// production ../Include/locking/Functionality</span>

<span class="k">namespace</span> <span class="n">locking</span>
<span class="p">{</span>
<span class="k">class</span> <span class="nc">Functionality</span>
<span class="p">{</span>
<span class="p">};</span>

<span class="p">}</span>

<span class="c1">// UT/Include/locking/Functionality</span>

<span class="cp">#include</span> <span class="cpf">“locking/Functionality.h”</span><span class="cp"></span>
<span class="cp">#include</span> <span class="cpf">“gtest/gtest.h”</span><span class="cp"></span>

<span class="k">namespace</span> <span class="n">locking</span>
<span class="p">{</span>

<span class="k">class</span> <span class="nc">FunctionalityTest</span> <span class="o">:</span> <span class="k">public</span> <span class="o">::</span><span class="n">testing</span><span class="o">::</span><span class="n">Test</span>
<span class="p">{</span>
<span class="p">};</span>

<span class="p">}</span>
</pre></div>
</div>
<blockquote>
<div><p>Listing 50. Namespace usage in test suites</p>
</div></blockquote>
</div>
<div class="section" id="test-cases">
<span id="header-n642"></span><h3>Test cases<a class="headerlink" href="#test-cases" title="Permalink to this headline">¶</a></h3>
<p>The name should be a sentence describing the results of the entity under
test. The subject can be omitted if it is implicit.</p>
<p>Examples:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TEST_F</span><span class="p">(</span><span class="n">InitialContextSetupHandlerTest</span><span class="p">,</span> <span class="n">releasesUeIfPayloadIsNotValid</span><span class="p">)</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">InitialContextSetupHandlerTest</span><span class="p">,</span> <span class="n">shouldReleaseUeIfPayloadIsNotValid</span><span class="p">)</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">InitialContextSetupHandlerTest</span><span class="p">,</span> <span class="n">testIfUeIsReleasedWhenPayloadIsNotValid</span><span class="p">)</span>
<span class="n">TEST</span><span class="p">(</span><span class="n">UeContainerTest</span><span class="p">,</span> <span class="n">findShouldReturnNullPtrWhenUeIdIsNotFound</span><span class="p">)</span>
</pre></div>
</div>
<p>In case of doubt about test case names, you can use following notation:
<a href="#id4"><span class="problematic" id="id5">`testedMethod\_ &lt;&gt;`__</span></a>[<a href="#id8"><span class="problematic" id="id9">whenYYY_</span></a>]shouldZZZ (note that the [] means
optional).</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TEST_F</span><span class="p">(</span><span class="n">EnbcTest</span><span class="p">,</span> <span class="n">release_givenValidPayload_whenEnbcIsNotReady_shouldQueueTheMessage</span><span class="p">)</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">EnbcTest</span><span class="p">,</span> <span class="n">whenEnbcIsNotReady_shouldQueueTheMessage</span><span class="p">)</span>
<span class="n">TEST_F</span><span class="p">(</span><span class="n">EnbcTest</span><span class="p">,</span> <span class="n">release_givenInvalidPayload_shouldThrow</span><span class="p">)</span>
</pre></div>
</div>
<p>Test cases should follow the AAA (Arrange Act Assert) layout shown
below:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">TEST_F</span><span class="p">(</span><span class="n">OamTest</span><span class="p">,</span> <span class="n">release_givenValidPayload_whenEnbcIsNotReady_shouldQueueTheMessage</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// arrange (given) – prepare environment for specific test case</span>
    <span class="c1">// act (when) – execute actions taking you to state you want to test</span>
    <span class="c1">// assert (should) – assertions, check result</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This may not be applicable to legacy or characterization tests.
Descriptive names should be as self–explanatory as possible. In
particular they shall not include DOORS references (e.g. CP 1234), as
these numbers are subject to change.</p>
<p>If the goal of two or more methods is to test given functionality in two
different ways (e.g. with different control flow), further naming
extension might be necessary. Like with all names, apply good taste and
common sense.</p>
</div>
<div class="section" id="header-n652">
<span id="id3"></span><h3>Comments<a class="headerlink" href="#header-n652" title="Permalink to this headline">¶</a></h3>
<p>Each test case can be commented using standard doxygen format if
necessary. Such a description should contain pre– and post–conditions
for the test case and a general explanation of the test scenario.</p>
</div>
<div class="section" id="helper-code">
<span id="header-n654"></span><h3>Helper code<a class="headerlink" href="#helper-code" title="Permalink to this headline">¶</a></h3>
<p>Helper functions used in unit tests should be declared as member
functions of the test suite class. If a helper class is needed, it is
advised to define it as private nested classes of the test suite or a
class in an anonymous namespace:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="k">struct</span> <span class="nl">MessageReceiverTestSuite</span> <span class="p">:</span> <span class="n">testing</span><span class="o">::</span><span class="n">Test</span>
<span class="p">{</span>
    <span class="c1">// helper class generating messages:</span>
    <span class="k">class</span> <span class="nc">MessageFactory</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

<span class="k">protected</span><span class="o">:</span>
   <span class="kt">void</span> <span class="n">testMessageDispatch</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
   <span class="c1">// helper function generating messages:</span>

   <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">Message</span><span class="o">&gt;</span>
   <span class="n">Message</span><span class="o">*</span> <span class="n">createMessage</span><span class="p">();</span>
<span class="p">};</span>
</pre></div>
</div>
<p>In case of helper classes that are used by multiple test suites, it’s
allowed to define them in separate files (and/or namespaces).</p>
</div>
<div class="section" id="google-mock-compilation-speed-up">
<span id="header-n658"></span><h3>Google mock compilation speed-up<a class="headerlink" href="#google-mock-compilation-speed-up" title="Permalink to this headline">¶</a></h3>
<p>When mocking big classes with many member functions (e.g.
MockConfigMgrService), it is advised to add empty implementation of
mock’s constructor and destructor in separate source file to speed up
compilation. The source file should be added to
../UT/Doubles/Source/MockConfigMgrService.cpp</p>
<p>Detailed explanation: for every mocked member function, also a
non-trivial template based data member is added. When compiler generates
the default constructor and destructor it has to instantiate constructor
for all such data members. By moving the constructor and destructor
implementation to source file, this code will be compiled only once
instead of every time the mocked class is instantiated in given
translation unit.</p>
</div>
</div>
<div class="section" id="terms-and-abbreviations">
<span id="header-n661"></span><h2>Terms and Abbreviations<a class="headerlink" href="#terms-and-abbreviations" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>IDE Integrated Development Environment, application integrating text
editor, build system, code navigation etc., e.g. Eclipse or Visual
Studio</p>
<p>POD Plain Old Data, type that has concrete binary representation and
can be copied in binary mode (i.e. old C structures)</p>
<p>STL Standard Template Library, C++ library providing containers and
algorithms general use, predecessor of C++98 Standard Library</p>
<p>CRTP Curiously Recurring Template Pattern</p>
<p>OAM Operation and Maintenance</p>
<p>CC&amp;S Common Computer &amp; Support Software</p>
</div></blockquote>
</div>
<div class="section" id="references">
<span id="header-n669"></span><h2>References<a class="headerlink" href="#references" title="Permalink to this headline">¶</a></h2>
<blockquote>
<div><p>[Ale01] Andrei Alexandrescu. Modern C++ Design: generic programming
and design patterns applied. Addison-Wesley, 2001.</p>
<p>[Cpp99] ISO-IEC 14882:2003, C++ Programming Language. International
Standards Organization, 1999.</p>
<p>[CSt99] ISO-IEC 9899:1999, C Programming Language. International
Standards Organization, 1999.</p>
<p>[GHJV95] Erich Gamma, Richard Helm, Ralph Johnson, and John
Vlissides. Design Patterns. Addison-Wesley, 1995.</p>
<p>[LW99] Barbara Liskov and Jeanette Wing. Behavioural sub typing using
invariants and constraints. 1999.</p>
<p>[MS98] Leonid Mikhajlov and Emil Sekerinski. A study of the fragile
base class problem. 1998.</p>
<p>[SA04] Herb Sutter and Andrei Alexandrescu. C++ Coding Standards: 101
Rules, Guidelines, and Best Practices (C++ in Depth Series).
Addison-Wesley, 2004.</p>
<p>[STL] Standard template library reference manual.</p>
<p>[Sut00] Herb Sutter. Exceptional C++: 47 engineering puzzles,
programming problems, and solutions. Addison-Wesley, 2000.</p>
</div></blockquote>
<p>[CppLTE]
<a class="reference external" href="https://sharenet-ims.inside.nokiasiemensnetworks.com/Guest/Open/D528156880">https://sharenet-ims.inside.nokiasiemensnetworks.com/Guest/Open/D528156880</a></p>
<blockquote>
<div><p>[CCon14] Herb Sutter. Back to the Basics! Essentials of Modern C++
Style. CppCon 2014. <a class="reference external" href="https://youtube.com/watch?v=xnqTKD8uD64">https://youtube.com/watch?v=xnqTKD8uD64</a> (12:10 –
28:22)</p>
<p>[CppCore] Bjarne Stroustrup, Herb Sutter. C++ Core Guidelines. 2015.</p>
<p><a class="reference external" href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#f42-return-a-t-to-indicate-a-position-only">https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#f42-return-a-t-to-indicate-a-position-only</a></p>
<p>[GoogleStd] Google Coding Standard.
<a class="reference external" href="https://google.github.io/styleguide/cppguide.html%20">https://google.github.io/styleguide/cppguide.html</a></p>
<p>[Doubles] <a class="reference external" href="https://en.wikipedia.org/wiki/Test_double">https://en.wikipedia.org/wiki/Test_double</a></p>
<p>[Formatter]
<a class="reference external" href="https://workspaces-emea.int.nokia.com/sites/FZFT12KRK/Wiki/Review">https://workspaces-emea.int.nokia.com/sites/FZFT12KRK/Wiki/Review</a>
process.asp</p>
</div></blockquote>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../readme.html" class="btn btn-neutral float-right" title="Readme" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../Development.html" class="btn btn-neutral float-left" title="Development" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, yueshen
      <span class="lastupdated">
        Last updated on Mar 19, 2020.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>